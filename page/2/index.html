<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="javascript, vue" />










<meta name="description" content="前端学习">
<meta property="og:type" content="website">
<meta property="og:title" content="STAO_blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="STAO_blog">
<meta property="og:description" content="前端学习">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'STAO'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>STAO_blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">STAO_blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/ElementUI%20%E4%B8%ADtab%E9%A1%B5%E5%A6%82%E4%BD%95%E5%AE%9E%E6%97%B6%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/18/ElementUI%20%E4%B8%ADtab%E9%A1%B5%E5%A6%82%E4%BD%95%E5%AE%9E%E6%97%B6%E5%8A%A0%E8%BD%BD/" itemprop="url">ElementUI 中tab页如何实时加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-18T17:32:13+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在vue中使用elementUI饿了么框架使用el-tabs，切换Tab如何实现实时加载，以及el-table表格使用总结<br>当我们在开发中遇到tab切换，这时候用el的el-tabs感觉很方便</p>
<p>但当我在把代码都写完后，发现一个问题就是页面打开时</p>
<p>虽然我们只能看见当前一个tab页，但是vue会帮你把你写的所有tab页的内容都渲染出来了，只是其他的隐藏了，同时其他tab的js也都走了一边，当你点击tab时js就不会再去请求后台</p>
<p>这种机制会造成一个问题，就是如果每个tab页的数据都过大的时候，可能就会导致首次打开页面卡顿现象，同时如果数据库数据在实时发生变化的话，比如你一分钟前打开的这个页面，看的是tab1的内容，看了1分钟后我想看tab2的内容，但此时tab2的内容后台数据库已经发生变化了，你能看到的只是1分钟前的数据，那该怎么解决这个问题呢？</p>
<p>首先一开始一次加载所有tab的代码是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-tabs v-model=&quot;activeName&quot; type=&quot;card&quot; @tab-click=&quot;handleClick&quot; style=&quot;margin-top:15px&quot;&gt;</span><br><span class="line">        &lt;el-tab-pane label=&quot;待质检&quot; name=&quot;second&quot;&gt;</span><br><span class="line">          &lt;second :form=&apos;form&apos; ref=&quot;childComponent&quot;&gt;&lt;/second&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt;</span><br><span class="line">        &lt;el-tab-pane label=&quot;已质检&quot; name=&quot;third&quot;&gt;</span><br><span class="line">          &lt;third :form=&apos;form&apos;&gt;&lt;/third&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt; </span><br><span class="line">        &lt;el-tab-pane label=&quot;待复议&quot; name=&quot;fourth&quot;&gt;</span><br><span class="line">          &lt;fourth :form=&apos;form&apos;&gt;&lt;/fourth&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt;</span><br><span class="line">        &lt;el-tab-pane label=&quot;已复议&quot; name=&quot;fifth&quot;&gt;</span><br><span class="line">          &lt;fifth :form=&apos;form&apos;&gt;&lt;/fifth&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt;</span><br><span class="line">      &lt;/el-tabs&gt;</span><br></pre></td></tr></table></figure>

<p>这时候v-if的作用就可以发挥出来了，当v-if的值为false时vue是不会去渲染该标签下的内容的</p>
<p>那我们就把tabs下的子模块标签上加v-if，一开始只设置其中一个为true其他都为false，当点击tab切换时去改变v-if的值，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-tabs v-model=&quot;activeName&quot; type=&quot;card&quot; @tab-click=&quot;handleClick&quot; style=&quot;margin-top:15px&quot;&gt;</span><br><span class="line">        &lt;el-tab-pane label=&quot;待质检&quot; name=&quot;second&quot;&gt;</span><br><span class="line">          &lt;second :form=&apos;form&apos; v-if=&quot;isSecond&quot; ref=&quot;childComponent&quot;&gt;&lt;/second&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt;</span><br><span class="line">        &lt;el-tab-pane label=&quot;已质检&quot; name=&quot;third&quot;&gt;</span><br><span class="line">          &lt;third :form=&apos;form&apos; v-if=&quot;isThird&quot;&gt;&lt;/third&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt; </span><br><span class="line">        &lt;el-tab-pane label=&quot;待复议&quot; name=&quot;fourth&quot;&gt;</span><br><span class="line">          &lt;fourth :form=&apos;form&apos; v-if=&quot;isFourth&quot;&gt;&lt;/fourth&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt;</span><br><span class="line">        &lt;el-tab-pane label=&quot;已复议&quot; name=&quot;fifth&quot;&gt;</span><br><span class="line">          &lt;fifth :form=&apos;form&apos; v-if=&quot;isFifth&quot;&gt;&lt;/fifth&gt;</span><br><span class="line">        &lt;/el-tab-pane&gt;</span><br><span class="line">      &lt;/el-tabs&gt;</span><br></pre></td></tr></table></figure>

<p>js的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import Second from &apos;./component/WaitQC.vue&apos;;</span><br><span class="line">import Third from &apos;./component/AlreadyQC.vue&apos;;</span><br><span class="line">import Fourth from &apos;./component/WaitReconsideration.vue&apos;;</span><br><span class="line">import Fifth from &apos;./component/AlreadyReconsideration.vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line"> components: &#123;</span><br><span class="line">        // &quot;first&quot;:First,</span><br><span class="line">        &quot;second&quot;:Second,</span><br><span class="line">        &quot;third&quot;:Third,</span><br><span class="line">        &quot;fourth&quot;:Fourth,</span><br><span class="line">        &quot;fifth&quot;:Fifth</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      activeName: &quot;second&quot;,</span><br><span class="line">      isSecond:true,</span><br><span class="line">      isThird:false,</span><br><span class="line">      isFourth:false,</span><br><span class="line">      isFifth:false,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  handleClick(tab, event)&#123;</span><br><span class="line">      if (tab.name === &apos;second&apos;) &#123;</span><br><span class="line">        this.isSecond = true;</span><br><span class="line">        this.isThird = false;</span><br><span class="line">        this.isFourth =false;</span><br><span class="line">        this.isFifth = false;</span><br><span class="line">      &#125; else if (tab.name === &apos;third&apos;) &#123;</span><br><span class="line">        this.isSecond = false;</span><br><span class="line">        this.isThird = true;</span><br><span class="line">        this.isFourth =false;</span><br><span class="line">        this.isFifth = false;</span><br><span class="line">      &#125;else if (tab.name === &apos;fourth&apos;) &#123;</span><br><span class="line">        this.isSecond = false;</span><br><span class="line">        this.isThird = false;</span><br><span class="line">        this.isFourth =true;</span><br><span class="line">        this.isFifth = false;</span><br><span class="line">      &#125;else if (tab.name === &apos;fifth&apos;) &#123;</span><br><span class="line">        this.isSecond = false;</span><br><span class="line">        this.isThird = false;</span><br><span class="line">        this.isFourth =false;</span><br><span class="line">        this.isFifth = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以完美解决上面的问题，首次加载页面只会渲染其中一个tab的内容，同时点击tab切换时页面重新渲染页面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/16/vue%E4%B8%AD'.%20native'%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/16/vue%E4%B8%AD'.%20native'%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/" itemprop="url">vue中'. native'修饰符的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-16T16:32:19+08:00">
                2020-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#官网的解释</p>
<p>你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native 。</p>
<p>通俗点讲：就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加’. native’事件是无法触发的。</p>
<p><img src="https://i.loli.net/2020/05/06/HC3IF5LrOVQEmgx.png" alt="企业微信截图_15887476222507.png"></p>
<p>此时点击页面中的按钮无任何反应。</p>
<pre><code>添加修饰符：</code></pre><p><img src="https://i.loli.net/2020/05/06/zUG4ESMm5wVfKay.png" alt="企业微信截图_15887476751898.png"></p>
<p> 此时点击就会弹窗：</p>
<p> <img src="https://i.loli.net/2020/05/06/mCAkJsb1MNQIHaY.png" alt="20180622114603852.png"></p>
<p> <strong><em>可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，并且该修饰符对普通HTML标签是没有任何作用的。</em></strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/05/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E4%BC%98%E5%8C%96%E7%AF%87)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/05/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E4%BC%98%E5%8C%96%E7%AF%87)/" itemprop="url">深度解锁Webpack系列(优化篇)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-05T14:32:34+08:00">
                2020-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="带你深度解锁Webpack系列-优化篇"><a href="#带你深度解锁Webpack系列-优化篇" class="headerlink" title="带你深度解锁Webpack系列(优化篇)"></a>带你深度解锁Webpack系列(优化篇)</h1><p><a href="https://juejin.im/post/5e5c65fc6fb9a07cd00d8838" target="_blank" rel="noopener">带你深度解锁Webpack系列(基础篇)</a> 和 <a href="https://juejin.im/post/5e6518946fb9a07c820fbaaf" target="_blank" rel="noopener">带你深度解锁Webpack系列(进阶篇)</a>，主要是讲解了 <code>Webpack</code> 的配置，但是随着项目越来越大，构建速度可能会越来越慢，构建出来的js的体积也越来越大，此时就需要对 <code>Webpack</code> 的配置进行优化。</p>
<p>本文罗列出了十多种优化方式，大家可以结合自己的项目，选择适当的方式进行优化。这些 <code>Webpack</code> 插件的源码我大多也没有看过，主要是结合 <code>Webpack</code> 官方文档以及项目实践，并且花了大量的时间验证后输出了本文，如果文中有错误的地方，欢迎在评论区指正。</p>
<p>鉴于前端技术变更迅速，祭出本篇文章基于 <code>Webpack</code> 的版本号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── webpack@4.41.5 </span><br><span class="line">└── webpack-cli@3.3.10 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>本文对应的项目地址(编写本文时使用)供参考：<a href="https://github.com/YvetteLau/webpack/tree/master/webpack-optimize" target="_blank" rel="noopener">github.com/YvetteLau/w…</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ee866b278?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>有时，我们以为的优化是负优化，这时，如果有一个量化的指标可以看出前后对比，那将会是再好不过的一件事。</p>
<p><code>speed-measure-webpack-plugin</code> 插件可以测量各个插件和<code>loader</code>所花费的时间，使用之后，构建时，会得到类似下面这样的信息：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf274c164c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="smp.jpeg"></p>
<p>对比前后的信息，来确定优化的效果。</p>
<p><a href="https://www.npmjs.com/package/speed-measure-webpack-plugin" target="_blank" rel="noopener">speed-measure-webpack-plugin</a> 的使用很简单，可以直接用其来包裹 <code>Webpack</code> 的配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);</span><br><span class="line">const smp = new SpeedMeasurePlugin();</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">    //...webpack配置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = smp.wrap(config);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="1-exclude-include"><a href="#1-exclude-include" class="headerlink" title="1.exclude/include"></a>1.exclude/include</h3><p>我们可以通过 <code>exclude</code>、<code>include</code> 配置来确保转译尽可能少的文件。顾名思义，<code>exclude</code> 指定要排除的文件，<code>include</code> 指定要包含的文件。</p>
<p><code>exclude</code> 的优先级高于 <code>include</code>，在 <code>include</code> 和 <code>exclude</code> 中使用绝对路径数组，尽量避免 <code>exclude</code>，更倾向于使用 <code>include</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js[x]?$/,</span><br><span class="line">                use: [&apos;babel-loader&apos;],</span><br><span class="line">                include: [path.resolve(__dirname, &apos;src&apos;)]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下图是我未配置 <code>include</code> 和配置了 <code>include</code> 的构建结果对比：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf279131194?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="include:exclude.jpeg"></p>
<h3 id="2-cache-loader"><a href="#2-cache-loader" class="headerlink" title="2. cache-loader"></a>2. cache-loader</h3><p>在一些性能开销较大的 <code>loader</code> 之前添加 <code>cache-loader</code>，将结果缓存中磁盘中。默认保存在 <code>node_modueles/.cache/cache-loader</code> 目录下。</p>
<p>首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install cache-loader -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>cache-loader</code> 的配置很简单，放在其他 <code>loader</code> 之前即可。修改<code>Webpack</code> 的配置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">    module: &#123;</span><br><span class="line">        //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.jsx?$/,</span><br><span class="line">                use: [&apos;cache-loader&apos;,&apos;babel-loader&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果你跟我一样，只打算给 <code>babel-loader</code> 配置 <code>cache</code> 的话，也可以不使用 <code>cache-loader</code>，给 <code>babel-loader</code> 增加选项 <code>cacheDirectory</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf279c1cd59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cache-loader.jpeg"></p>
<p><code>cacheDirectory</code>：默认值为 <code>false</code>。当有设置时，指定的目录将用来缓存 <code>loader</code> 的执行结果。之后的 <code>Webpack</code> 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 <code>Babel</code> 重新编译过程。设置空值或者 <code>true</code> 的话，使用默认缓存目录：<code>node_modules/.cache/babel-loader</code>。开启 <code>babel-loader</code>的缓存和配置 <code>cache-loader</code>，我比对了下，构建时间很接近。</p>
<h3 id="3-happypack"><a href="#3-happypack" class="headerlink" title="3.happypack"></a>3.happypack</h3><p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，<code>Webpack</code> 构建慢的问题会显得严重。文件读写和计算操作是无法避免的，那能不能让 <code>Webpack</code> 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？</p>
<p><code>HappyPack</code> 就能让 <code>Webpack</code> 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。</p>
<p>首先需要安装 <code>happypack</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install happypack -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const Happypack = require(&apos;happypack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js[x]?$/,</span><br><span class="line">                use: &apos;Happypack/loader?id=js&apos;,</span><br><span class="line">                include: [path.resolve(__dirname, &apos;src&apos;)]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: &apos;Happypack/loader?id=css&apos;,</span><br><span class="line">                include: [</span><br><span class="line">                    path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">                    path.resolve(__dirname, &apos;node_modules&apos;, &apos;bootstrap&apos;, &apos;dist&apos;)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new Happypack(&#123;</span><br><span class="line">            id: &apos;js&apos;, //和rule中的id=js对应</span><br><span class="line">            //将之前 rule 中的 loader 在此配置</span><br><span class="line">            use: [&apos;babel-loader&apos;] //必须是数组</span><br><span class="line">        &#125;),</span><br><span class="line">        new Happypack(&#123;</span><br><span class="line">            id: &apos;css&apos;,//和rule中的id=css对应</span><br><span class="line">            use: [&apos;style-loader&apos;, &apos;css-loader&apos;,&apos;postcss-loader&apos;],</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>happypack</code> 默认开启 <code>CPU核数 - 1</code> 个进程，当然，我们也可以传递 <code>threads</code> 给 <code>Happypack</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf27caaa71c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="happypack.jpeg"></p>
<p>说明：当 <code>postcss-loader</code> 配置在 <code>Happypack</code> 中，必须要在项目中创建 <code>postcss.config.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        require(&apos;autoprefixer&apos;)()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>否则，会抛出错误: <code>Error: No PostCSS Config found</code></p>
<p>另外，当你的项目不是很复杂时，不需要配置 <code>happypack</code>，因为进程的分配和管理也需要时间，并不能有效提升构建速度，甚至会变慢。</p>
<h3 id="4-thread-loader"><a href="#4-thread-loader" class="headerlink" title="4.thread-loader"></a>4.thread-loader</h3><p>除了使用 <code>Happypack</code> 外，我们也可以使用 <code>thread-loader</code> ，把 <code>thread-loader</code> 放置在其它 <code>loader</code> 之前，那么放置在这个 <code>loader</code> 之后的 <code>loader</code> 就会在一个单独的 <code>worker</code> 池中运行。</p>
<p>在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：</p>
<ul>
<li>这些 <code>loader</code> 不能产生新的文件。</li>
<li>这些 <code>loader</code> 不能使用定制的 <code>loader</code> API（也就是说，通过插件）。</li>
<li>这些 <code>loader</code> 无法获取 <code>webpack</code> 的选项设置。</li>
</ul>
<p>首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install thread-loader -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        //我的项目中,babel-loader耗时比较长，所以我给它配置 thread-loader</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.jsx?$/,</span><br><span class="line">                use: [&apos;thread-loader&apos;, &apos;cache-loader&apos;, &apos;babel-loader&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>thread-loader</code> 和 <code>Happypack</code> 我对比了一下，构建时间基本没什么差别。不过 <code>thread-loader</code> 配置起来为简单。</p>
<h3 id="5-开启-JS-多进程压缩"><a href="#5-开启-JS-多进程压缩" class="headerlink" title="5.开启 JS 多进程压缩"></a>5.开启 JS 多进程压缩</h3><p>虽然很多 <code>webpack</code> 优化的文章上会提及多进程压缩的优化，不管是 <code>webpack-parallel-uglify-plugin</code> 或者是 <code>uglifyjs-webpack-plugin</code> 配置 <code>parallel</code>。不过这里我要说一句，没必要单独安装这些插件，它们并不会让你的 <code>Webpack</code> 构建速度提升。</p>
<p>当前 <code>Webpack</code> 默认使用的是 <code>TerserWebpackPlugin</code>，默认就开启了多进程和缓存，构建时，你的项目中可以看到 <code>terser</code> 的缓存文件 <code>node_modules/.cache/terser-webpack-plugin</code>。</p>
<h3 id="6-HardSourceWebpackPlugin"><a href="#6-HardSourceWebpackPlugin" class="headerlink" title="6.HardSourceWebpackPlugin"></a>6.HardSourceWebpackPlugin</h3><p><code>HardSourceWebpackPlugin</code> 为模块提供中间缓存，缓存默认的存放路径是: <code>node_modules/.cache/hard-source</code>。</p>
<p>配置 <code>hard-source-webpack-plugin</code>，首次构建时间没有太大变化，但是第二次开始，构建时间大约可以节约 80%。</p>
<p>首先安装依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hard-source-webpack-plugin -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改 <code>webpack</code> 的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">var HardSourceWebpackPlugin = require(&apos;hard-source-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new HardSourceWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf27e20fd0e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>用另外一个比较大的项目测试了下，配置了 <code>HardSourceWebpackPlugin</code>，构建时间从 8S 左右降到了 2S 左右。</p>
<p><a href="https://www.npmjs.com/package/hard-source-webpack-plugin" target="_blank" rel="noopener">HardSourceWebpackPlugin文档中</a> 列出了一些你可能会遇到的问题以及如何解决，例如热更新失效，或者某些配置不生效等。</p>
<h3 id="7-noParse"><a href="#7-noParse" class="headerlink" title="7.noParse"></a>7.noParse</h3><p>如果一些第三方模块没有AMD/CommonJS规范版本，可以使用 <code>noParse</code> 来标识这个模块，这样 <code>Webpack</code> 会引入这些模块，但是不进行转化和解析，从而提升 <code>Webpack</code> 的构建性能 ，例如：<code>jquery</code> 、<code>lodash</code>。</p>
<p><a href="http://webpack.html.cn/configuration/module.html" target="_blank" rel="noopener">noParse</a> 属性的值是一个正则表达式或者是一个 <code>function</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    module: &#123;</span><br><span class="line">        noParse: /jquery|lodash/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我当前的 <code>webpack-optimize</code> 项目中，没有使用 <code>jquery</code> 或者是 <code>lodash</code>。</p>
<p>因此新建一个项目测试，只引入 <code>jquery</code> 和 <code>loadsh</code>，然后配置 <code>noParse</code> 和不配置 <code>noParse</code>，分别构建比对时间。</p>
<p>配置<code>noParse</code> 前，构建需要 <code>2392ms</code>。配置了 <code>noParse</code> 之后，构建需要 <code>1613ms</code>。 如果你使用到了不需要解析的第三方依赖，那么配置 <code>noParse</code> 很显然是一定会起到优化作用的。</p>
<h3 id="8-resolve"><a href="#8-resolve" class="headerlink" title="8.resolve"></a>8.resolve</h3><p><code>resolve</code> 配置 <code>webpack</code> 如何寻找模块所对应的文件。假设我们确定模块都从根目录下的 <code>node_modules</code> 中查找，我们可以配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        modules: [path.resolve(__dirname, &apos;node_modules&apos;)],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>需要记住的是，如果你配置了上述的 <code>resolve.moudles</code> ，可能会出现问题，例如，你的依赖中还存在 <code>node_modules</code> 目录，那么就会出现，对应的文件明明在，但是却提示找不到。因此呢，个人不推荐配置这个。如果其他同事不熟悉这个配置，遇到这个问题时，会摸不着头脑。</p>
<p>另外，<code>resolve</code> 的 <code>extensions</code> 配置，默认是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你要对它进行配置，记住将频率最高的后缀放在第一位，并且控制列表的长度，以减少尝试次数。</p>
<p>本项目较小，因此测试时，此处优化效果不明显。</p>
<h3 id="9-IgnorePlugin"><a href="#9-IgnorePlugin" class="headerlink" title="9.IgnorePlugin"></a>9.IgnorePlugin</h3><p><code>webpack</code> 的内置插件，作用是忽略第三方包指定目录。</p>
<p>例如: <code>moment</code> (2.24.0版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 <code>IgnorePlugin</code> 在打包时忽略本地化内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        //忽略 moment 下的 ./locale 目录</span><br><span class="line">        new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在使用的时候，如果我们需要指定语言，那么需要我们手动的去引入语言包，例如，引入中文语言包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import moment from &apos;moment&apos;;</span><br><span class="line">import &apos;moment/locale/zh-cn&apos;;// 手动引入</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>index.js</code> 中只引入 <code>moment</code>，打包出来的 <code>bundle.js</code> 大小为 <code>263KB</code>，如果配置了 <code>IgnorePlugin</code>，单独引入 <code>moment/locale/zh-cn</code>，构建出来的包大小为 <code>55KB</code>。</p>
<h3 id="10-externals"><a href="#10-externals" class="headerlink" title="10.externals"></a>10.externals</h3><p>我们可以将一些JS文件存储在 <code>CDN</code> 上(减少 <code>Webpack</code>打包出来的 <code>js</code> 体积)，在 <code>index.html</code> 中通过 `` 标签引入，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;root&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们希望在使用时，仍然可以通过 <code>import</code> 的方式去引用(如 <code>import $ from &#39;jquery&#39;</code>)，并且希望 <code>webpack</code> 不会对其进行打包，此时就可以配置 <code>externals</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    externals: &#123;</span><br><span class="line">        //jquery通过script引入之后，全局中即有了 jQuery 变量</span><br><span class="line">        &apos;jquery&apos;: &apos;jQuery&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="11-DllPlugin"><a href="#11-DllPlugin" class="headerlink" title="11.DllPlugin"></a>11.DllPlugin</h3><p>有些时候，如果所有的JS文件都打成一个JS文件，会导致最终生成的JS文件很大，这个时候，我们就要考虑拆分 <code>bundles</code>。</p>
<p><code>DllPlugin</code> 和 <code>DLLReferencePlugin</code> 可以实现拆分 <code>bundles</code>，并且可以大大提升构建速度，<code>DllPlugin</code> 和 <code>DLLReferencePlugin</code> 都是 <code>webpack</code> 的内置模块。</p>
<p>我们使用 <code>DllPlugin</code> 将不会频繁更新的库进行编译，当这些依赖的版本没有变化时，就不需要重新编译。我们新建一个 <code>webpack</code> 的配置文件，来专门用于编译动态链接库，例如名为: <code>webpack.config.dll.js</code>，这里我们将 <code>react</code> 和 <code>react-dom</code> 单独打包成一个动态链接库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.dll.js</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react: [&apos;react&apos;, &apos;react-dom&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &apos;production&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].dll.[hash:6].js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;, &apos;dll&apos;),</span><br><span class="line">        library: &apos;[name]_dll&apos; //暴露给外部使用</span><br><span class="line">        //libraryTarget 指定如何暴露内容，缺省时就是 var</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllPlugin(&#123;</span><br><span class="line">            //name和library一致</span><br><span class="line">            name: &apos;[name]_dll&apos;, </span><br><span class="line">            path: path.resolve(__dirname, &apos;dist&apos;, &apos;dll&apos;, &apos;manifest.json&apos;) //manifest.json的生成路径</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在 <code>package.json</code> 的 <code>scripts</code> 中增加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;dev&quot;: &quot;NODE_ENV=development webpack-dev-server&quot;,</span><br><span class="line">        &quot;build&quot;: &quot;NODE_ENV=production webpack&quot;,</span><br><span class="line">        &quot;build:dll&quot;: &quot;webpack --config webpack.config.dll.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行 <code>npm run build:all</code>，可以看到 <code>dist</code> 目录如下，之所以将动态链接库单独放在 <code>dll</code> 目录下，主要是为了使用 <code>CleanWebpackPlugin</code> 更为方便的过滤掉动态链接库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dist</span><br><span class="line">└── dll</span><br><span class="line">    ├── manifest.json</span><br><span class="line">    └── react.dll.9dcd9d.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>manifest.json</code> 用于让 <code>DLLReferencePlugin</code> 映射到相关依赖上。</p>
<p>修改 <code>webpack</code> 的主配置文件: <code>webpack.config.js</code> 的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllReferencePlugin(&#123;</span><br><span class="line">            manifest: path.resolve(__dirname, &apos;dist&apos;, &apos;dll&apos;, &apos;manifest.json&apos;)</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin(&#123;</span><br><span class="line">            cleanOnceBeforeBuildPatterns: [&apos;**/*&apos;, &apos;!dll&apos;, &apos;!dll/**&apos;] //不删除dll目录</span><br><span class="line">        &#125;),</span><br><span class="line">        //...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用 <code>npm run build</code> 构建，可以看到 <code>bundle.js</code> 的体积大大减少。</p>
<p>修改 <code>public/index.html</code> 文件，在其中引入 <code>react.dll.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/dll/react.dll.9dcd9d.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<p>构建速度</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf27efef7f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="DllPlugin.jpeg"></p>
<blockquote>
<p>包体积</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf2f995e7e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dll-size.jpeg"></p>
</blockquote>
<h3 id="12-抽离公共代码"><a href="#12-抽离公共代码" class="headerlink" title="12.抽离公共代码"></a>12.抽离公共代码</h3><p>抽离公共代码是对于多页应用来说的，如果多个页面引入了一些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载一次就缓存起来了，避免了重复下载。</p>
<p>抽离公共代码对于单页应用和多页应该在配置上没有什么区别，都是配置在 <code>optimization.splitChunks</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;//分割代码块</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                vendor: &#123;</span><br><span class="line">                    //第三方依赖</span><br><span class="line">                    priority: 1, //设置优先级，首先抽离第三方模块</span><br><span class="line">                    name: &apos;vendor&apos;,</span><br><span class="line">                    test: /node_modules/,</span><br><span class="line">                    chunks: &apos;initial&apos;,</span><br><span class="line">                    minSize: 0,</span><br><span class="line">                    minChunks: 1 //最少引入了1次</span><br><span class="line">                &#125;,</span><br><span class="line">                //缓存组</span><br><span class="line">                common: &#123;</span><br><span class="line">                    //公共模块</span><br><span class="line">                    chunks: &apos;initial&apos;,</span><br><span class="line">                    name: &apos;common&apos;,</span><br><span class="line">                    minSize: 100, //大小超过100个字节</span><br><span class="line">                    minChunks: 3 //最少引入了3次</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>即使是单页应用，同样可以使用这个配置，例如，打包出来的 bundle.js 体积过大，我们可以将一些依赖打包成动态链接库，然后将剩下的第三方依赖拆出来。这样可以有效减小 bundle.js 的体积大小。当然，你还可以继续提取业务代码的公共模块，此处，因为我项目中源码较少，所以没有配置。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf31f45e7a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="splitChunks.jpeg"></p>
<blockquote>
<p>runtimeChunk</p>
</blockquote>
<p><code>runtimeChunk</code> 的作用是将包含 <code>chunk</code> 映射关系的列表从 <code>main.js</code> 中抽离出来，在配置了 <code>splitChunk</code> 时，记得配置 <code>runtimeChunk</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        runtimeChunk: &#123;</span><br><span class="line">            name: &apos;manifest&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最终构建出来的文件中会生成一个 <code>manifest.js</code>。</p>
<h4 id="借助-webpack-bundle-analyzer-进一步优化"><a href="#借助-webpack-bundle-analyzer-进一步优化" class="headerlink" title="借助 webpack-bundle-analyzer 进一步优化"></a>借助 webpack-bundle-analyzer 进一步优化</h4><p>在做 <code>webpack</code> 构建优化的时候，<code>vendor</code> 打出来超过了1M，<code>react</code> 和 <code>react-dom</code> 已经打包成了DLL。</p>
<p>因此需要借助 <code>webpack-bundle-analyzer</code> 查看一下是哪些包的体积较大。</p>
<p>首先安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用也很简单，修改下我们的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.prod.js</span><br><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const baseWebpackConfig = require(&apos;./webpack.config.base&apos;);</span><br><span class="line">module.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">    //....</span><br><span class="line">    plugins: [</span><br><span class="line">        //...</span><br><span class="line">        new BundleAnalyzerPlugin(),</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>npm run build</code> 构建，会默认打开： <code>http://127.0.0.1:8888/</code>，可以看到各个包的体积：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf330fb2a0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="W1.jpeg"></p>
<p>进一步对 <code>vendor</code> 进行拆分，将 <code>vendor</code> 拆分成了4个(使用 <code>splitChunks</code> 进行拆分即可)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">    concatenateModules: false,</span><br><span class="line">    splitChunks: &#123;//分割代码块</span><br><span class="line">      maxInitialRequests:6, //默认是5</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          //第三方依赖</span><br><span class="line">          priority: 1,</span><br><span class="line">          name: &apos;vendor&apos;,</span><br><span class="line">          test: /node_modules/,</span><br><span class="line">          chunks: &apos;initial&apos;,</span><br><span class="line">          minSize: 100,</span><br><span class="line">          minChunks: 1 //重复引入了几次</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;lottie-web&apos;: &#123;</span><br><span class="line">          name: &quot;lottie-web&quot;, // 单独将 react-lottie 拆包</span><br><span class="line">          priority: 5, // 权重需大于`vendor`</span><br><span class="line">          test: /[\/]node_modules[\/]lottie-web[\/]/,</span><br><span class="line">          chunks: &apos;initial&apos;,</span><br><span class="line">          minSize: 100,</span><br><span class="line">          minChunks: 1 //重复引入了几次</span><br><span class="line">        &#125;,</span><br><span class="line">        //...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>重新构建，结果如下所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf36fcad19c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="W2.jpeg"></p>
<h3 id="13-webpack自身的优化"><a href="#13-webpack自身的优化" class="headerlink" title="13.webpack自身的优化"></a>13.webpack自身的优化</h3><h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h4><p>如果使用ES6的<code>import</code> 语法，那么在生产环境下，会自动移除没有使用到的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//math.js</span><br><span class="line">const add = (a, b) =&gt; &#123;</span><br><span class="line">    console.log(&apos;aaaaaa&apos;)</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const minus = (a, b) =&gt; &#123;</span><br><span class="line">    console.log(&apos;bbbbbb&apos;)</span><br><span class="line">    return a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    add,</span><br><span class="line">    minus</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">//index.js</span><br><span class="line">import &#123;add, minus&#125; from &apos;./math&apos;;</span><br><span class="line">add(2,3);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>构建的最终代码里，<code>minus</code> 函数不会被打包进去。</p>
<h4 id="scope-hosting-作用域提升"><a href="#scope-hosting-作用域提升" class="headerlink" title="scope hosting 作用域提升"></a>scope hosting 作用域提升</h4><p>变量提升，可以减少一些变量声明。在生产环境下，默认开启。</p>
<p>另外，大家测试的时候注意一下，<code>speed-measure-webpack-plugin</code> 和 <code>HotModuleReplacementPlugin</code> 不能同时使用，否则会报错:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d9bf389ae1379?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="babel-配置的优化"><a href="#babel-配置的优化" class="headerlink" title="babel 配置的优化"></a>babel 配置的优化</h4><p>如果你对 <code>babel</code> 还不太熟悉的话，那么可以阅读这篇文章：<a href="https://juejin.im/post/5ddff3abe51d4502d56bd143" target="_blank" rel="noopener">不容错过的 Babel7 知识</a>。</p>
<p>在不配置 <code>@babel/plugin-transform-runtime</code> 时，<code>babel</code> 会使用很小的辅助函数来实现类似 <code>_createClass</code> 等公共方法。默认情况下，它将被注入(<code>inject</code>)到需要它的每个文件中。但是这样的结果就是导致构建出来的JS体积变大。</p>
<p>我们也并不需要在每个 <code>js</code> 中注入辅助函数，因此我们可以使用 <code>@babel/plugin-transform-runtime</code>，<code>@babel/plugin-transform-runtime</code> 是一个可以重复使用 <code>Babel</code> 注入的帮助程序，以节省代码大小的插件。</p>
<p>因此我们可以在 <code>.babelrc</code> 中增加 <code>@babel/plugin-transform-runtime</code> 的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;@babel/plugin-transform-runtime&quot;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上就是我目前为止使用到的一些优化，如果你有更好的优化方式，欢迎在评论区留言，感谢阅读。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E8%BF%9B%E9%98%B6%E7%AF%87)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E8%BF%9B%E9%98%B6%E7%AF%87)/" itemprop="url">深度解锁Webpack系列(进阶篇)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-04T14:32:34+08:00">
                2020-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="带你深度解锁Webpack系列-进阶篇"><a href="#带你深度解锁Webpack系列-进阶篇" class="headerlink" title="带你深度解锁Webpack系列(进阶篇)"></a>带你深度解锁Webpack系列(进阶篇)</h1><p>三篇长文，带你解锁 <code>Webpack</code> ，希望读完这三篇文章，你能够对 <code>webpack</code> 的各项配置有一个更为清晰的认识。</p>
<p>本文是第二篇，如果你还没有阅读<a href="https://juejin.im/post/5e5c65fc6fb9a07cd00d8838" target="_blank" rel="noopener">《带你深度解锁Webpack系列(基础篇)》</a>，建议阅读之后，再继续阅读本文。</p>
<p>本文会引入更多的 <code>webpack</code> 配置，如果文中有任何错误，欢迎在评论区指正，我会尽快修正。 <code>webpack</code> 优化部分放在了下一篇。</p>
<p>推荐大家参考本文一步一步进行配置，不要总是想着找什么最佳配置，掌握之后，根据自己的需求配置出来的，就是最佳配置。</p>
<p>本文对应的项目地址(编写本文时使用) 供参考：<a href="https://github.com/YvetteLau/webpack/tree/master/webpack-second" target="_blank" rel="noopener">github.com/YvetteLau/w…</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ee866b278?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="1-静态资源拷贝"><a href="#1-静态资源拷贝" class="headerlink" title="1. 静态资源拷贝"></a>1. 静态资源拷贝</h3><p>有些时候，我们需要使用已有的JS文件、CSS文件（本地文件），但是不需要 <code>webpack</code> 编译。例如，我们在 <code>public/index.html</code> 中引入了 <code>public</code> 目录下的 <code>js</code> 或 <code>css</code> 文件。这个时候，如果直接打包，那么在构建出来之后，肯定是找不到对应的 <code>js</code> / <code>css</code> 了。</p>
<blockquote>
<p><code>public</code> 目录结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── public</span><br><span class="line">│   ├── config.js</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   │   ├── base.js</span><br><span class="line">│   │   └── other.js</span><br><span class="line">│   └── login.html</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在，我们在 <code>index.html</code> 中引入了 <code>./js/base.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;script src=&quot;./js/base.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这时候，我们 <code>npm run dev</code>，会发现有找不到该资源文件的报错信息。</p>
<p>对于这个问题，我们可以手动将其拷贝至构建目录，然后在配置 <code>CleanWebpackPlugin</code> 时，注意不要清空对应的文件或文件夹即可，但是如若这个静态文件时不时的还会修改下，那么依赖于手动拷贝，是很容易出问题的。</p>
<p>不要过于相信自己的记性，依赖于手动拷贝的方式，大多数人应该都有过忘记拷贝的经历，你要是说你从来没忘过。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7eedad0932?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="050a81c7-59e4-4596-b08f-62cefce353d0.jpg"></p>
<p>幸运的是，<code>webpack</code> 为我们这些记性不好又爱偷懒的人提供了好用的插件 <a href="https://webpack.js.org/plugins/copy-webpack-plugin/" target="_blank" rel="noopener">CopyWebpackPlugin</a>，它的作用就是将单个文件或整个目录复制到构建目录。</p>
<p>首先安装一下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install copy-webpack-plugin -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改配置(当前，需要做的是将 <code>public/js</code> 目录拷贝至 <code>dist/js</code> 目录)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new CopyWebpackPlugin([</span><br><span class="line">            &#123;</span><br><span class="line">                from: &apos;public/js/*.js&apos;,</span><br><span class="line">                to: path.resolve(__dirname, &apos;dist&apos;, &apos;js&apos;),</span><br><span class="line">                flatten: true,</span><br><span class="line">            &#125;,</span><br><span class="line">            //还可以继续配置其它要拷贝的文件</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时，重新执行 <code>npm run dev</code>，报错信息已经消失。</p>
<p>这里说一下 <code>flatten</code> 这个参数，设置为 <code>true</code>，那么它只会拷贝文件，而不会把文件夹路径都拷贝上，大家可以不设置 <code>flatten</code> 时，看下构建结果。</p>
<p>另外，如果我们要拷贝一个目录下的很多文件，但是想过滤掉某个或某些文件，那么 <code>CopyWebpackPlugin</code> 还为我们提供了 <code>ignore</code> 参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new CopyWebpackPlugin([</span><br><span class="line">            &#123;</span><br><span class="line">                from: &apos;public/js/*.js&apos;,</span><br><span class="line">                to: path.resolve(__dirname, &apos;dist&apos;, &apos;js&apos;),</span><br><span class="line">                flatten: true,</span><br><span class="line">            &#125;</span><br><span class="line">        ], &#123;</span><br><span class="line">            ignore: [&apos;other.js&apos;]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>例如，这里我们忽略掉 <code>js</code> 目录下的 <code>other.js</code> 文件，使用 <code>npm run build</code> 构建，可以看到 <code>dist/js</code> 下不会出现 <code>other.js</code> 文件。 <code>CopyWebpackPlugin</code> 还提供了很多其它的参数，如果当前的配置不能满足你，可以查阅文档进一步修改配置。</p>
<h3 id="2-ProvidePlugin"><a href="#2-ProvidePlugin" class="headerlink" title="2.ProvidePlugin"></a>2.ProvidePlugin</h3><p><code>ProvidePlugin</code> 在我看来，是为懒人准备的，不过也别过度使用，毕竟全局变量不是什么“好东西”。<code>ProvidePlugin</code> 的作用就是不需要 <code>import</code> 或 <code>require</code> 就可以在项目中到处使用。</p>
<p><code>ProvidePlugin</code> 是 <code>webpack</code> 的内置插件，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">  identifier1: &apos;module1&apos;,</span><br><span class="line">  identifier2: [&apos;module2&apos;, &apos;property2&apos;]</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>默认寻找路径是当前文件夹 <code>./**</code> 和 <code>node_modules</code>，当然啦，你可以指定全路径。</p>
<p><code>React</code> 大家都知道的，使用的时候，要在每个文件中引入 <code>React</code>，不然立刻抛错给你看。还有就是 <code>jquery</code>, <code>lodash</code> 这样的库，可能在多个文件中使用，但是懒得每次都引入，好嘛，一起来偷个懒，修改下 <code>webpack</code> 的配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.ProvidePlugin(&#123;</span><br><span class="line">            React: &apos;react&apos;,</span><br><span class="line">            Component: [&apos;react&apos;, &apos;Component&apos;],</span><br><span class="line">            Vue: [&apos;vue/dist/vue.esm.js&apos;, &apos;default&apos;],</span><br><span class="line">            $: &apos;jquery&apos;,</span><br><span class="line">            _map: [&apos;lodash&apos;, &apos;map&apos;]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样配置之后，你就可以在项目中随心所欲的使用 <code>$</code>、<code>_map</code>了，并且写 <code>React</code> 组件时，也不需要 <code>import</code> <code>React</code> 和 <code>Component</code> 了，如果你想的话，你还可以把 <code>React</code> 的 <code>Hooks</code> 都配置在这里。</p>
<p>另外呢，<code>Vue</code> 的配置后面多了一个 <code>default</code>，这是因为 <code>vue.esm.js</code> 中使用的是 <code>export default</code> 导出的，对于这种，必须要指定 <code>default</code>。<code>React</code> 使用的是 <code>module.exports</code> 导出的，因此不要写 <code>default</code>。</p>
<p>另外，就是如果你项目启动了 <code>eslint</code> 的话，记得修改下 <code>eslint</code> 的配置文件，增加以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;globals&quot;: &#123;</span><br><span class="line">        &quot;React&quot;: true,</span><br><span class="line">        &quot;Vue&quot;: true,</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然啦，偷懒要有个度，你要是配一大堆全局变量，最终可能会给自己带来麻烦，对自己配置的全局变量一定要负责到底。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef26d2ca3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="u=2243033496,1576809017&amp;fm=15&amp;gp=0.jpg"></p>
<h3 id="3-抽离CSS"><a href="#3-抽离CSS" class="headerlink" title="3.抽离CSS"></a>3.抽离CSS</h3><p>CSS打包我们前面已经说过了，不过呢，有些时候，我们可能会有抽离CSS的需求，即将CSS文件单独打包，这可能是因为打包成一个JS文件太大，影响加载速度，也有可能是为了缓存(例如，只有JS部分有改动)，还有可能就是“我高兴”：我想抽离就抽离，谁也管不着。</p>
<p>不管你是因为什么原因要抽离CSS，只要你有需求，我们就可以去实现。</p>
<p>首先，安装 <code>loader</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>mini-css-extract-plugin</code> 和 <code>extract-text-webpack-plugin</code> 相比:</p>
</blockquote>
<ol>
<li>异步加载</li>
<li>不会重复编译(性能更好)</li>
<li>更容易使用</li>
<li>只适用CSS</li>
</ol>
<p>修改我们的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &apos;css/[name].css&apos;</span><br><span class="line">            //个人习惯将css文件放在单独目录下</span><br><span class="line">            //publicPath:&apos;../&apos;   //如果你的output的publicPath配置的是 &apos;./&apos; 这种相对路径，那么如果将css文件放在单独目录下，记得在这里指定一下publicPath </span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(le|c)ss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader, //替换之前的 style-loader</span><br><span class="line">                    &apos;css-loader&apos;, &#123;</span><br><span class="line">                        loader: &apos;postcss-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            plugins: function () &#123;</span><br><span class="line">                                return [</span><br><span class="line">                                    require(&apos;autoprefixer&apos;)(&#123;</span><br><span class="line">                                        &quot;overrideBrowserslist&quot;: [</span><br><span class="line">                                            &quot;defaults&quot;</span><br><span class="line">                                        ]</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, &apos;less-loader&apos;</span><br><span class="line">                ],</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在，我们重新编译：<code>npm run build</code>，目录结构如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   ├── alita_e09b5c.jpg</span><br><span class="line">│   │   └── thor_e09b5c.jpeg</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   ├── index.css</span><br><span class="line">│   │   └── index.css.map</span><br><span class="line">│   ├── bundle.fb6d0c.js</span><br><span class="line">│   ├── bundle.fb6d0c.js.map</span><br><span class="line">│   └── index.html</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>前面说了最好新建一个 <code>.browserslistrc</code> 文件，这样可以多个 <code>loader</code> 共享配置，所以，动手在根目录下新建文件 (<code>.browserslistrc</code>)，内容如下（你可以根据自己项目需求，修改为其它的配置）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">last 2 version</span><br><span class="line">&gt; 0.25%</span><br><span class="line">not dead</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改 <code>webpack.config.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &apos;css/[name].css&apos; </span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(c|le)ss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &apos;css-loader&apos;, &#123;</span><br><span class="line">                        loader: &apos;postcss-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            plugins: function () &#123;</span><br><span class="line">                                return [</span><br><span class="line">                                    require(&apos;autoprefixer&apos;)()</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, &apos;less-loader&apos;</span><br><span class="line">                ],</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>要测试自己的 <code>.browserlistrc</code> 有没有生效也很简单，直接将文件内容修改为 <code>last 1 Chrome versions</code> ，然后对比修改前后的构建出的结果，就能看出来啦。</p>
<p>可以查看更多[browserslistrc]配置项(<a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">github.com/browserslis…</a>)</p>
<p>更多配置项，可以查看<a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a></p>
<h4 id="将抽离出来的css文件进行压缩"><a href="#将抽离出来的css文件进行压缩" class="headerlink" title="将抽离出来的css文件进行压缩"></a>将抽离出来的css文件进行压缩</h4><p>使用 <code>mini-css-extract-plugin</code>，<code>CSS</code> 文件默认不会被压缩，如果想要压缩，需要配置 <code>optimization</code>，首先安装 <code>optimize-css-assets-webpack-plugin</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改webpack配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const OptimizeCssPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    //....</span><br><span class="line">    plugins: [</span><br><span class="line">        new OptimizeCssPlugin()</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>注意，这里将 <code>OptimizeCssPlugin</code> 直接配置在 <code>plugins</code> 里面，那么 <code>js</code> 和 <code>css</code> 都能够正常压缩，如果你将这个配置在 <code>optimization</code>，那么需要再配置一下 <code>js</code> 的压缩(开发环境下不需要去做CSS的压缩，因此后面记得将其放到 <code>webpack.config.prod.js</code> 中哈)。</p>
<p>配置完之后，测试的时候发现，抽离之后，修改 <code>css</code> 文件时，第一次页面会刷新，但是第二次页面不会刷新 —— 好嘛，我平时的业务中用不着抽离 <code>css</code>，这个问题搁置了好多天(准确来说是忘记了)。</p>
<p>3月8号再次修改这篇文章的时候，正好看到了 <code>MiniCssExtractPlugin.loader</code> 对应的 <code>option</code> 设置，我们再次修改下对应的 <code>rule</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.(c|le)ss$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: MiniCssExtractPlugin.loader,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        hmr: isDev,</span><br><span class="line">                        reloadAll: true,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                //...</span><br><span class="line">            ],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef4ea39dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="4-按需加载"><a href="#4-按需加载" class="headerlink" title="4.按需加载"></a>4.按需加载</h3><p>很多时候我们不需要一次性加载所有的JS文件，而应该在不同阶段去加载所需要的代码。<code>webpack</code>内置了强大的分割代码的功能可以实现按需加载。</p>
<p>比如，我们在点击了某个按钮之后，才需要使用使用对应的JS文件中的代码，需要使用 <code>import()</code> 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;btn&apos;).onclick = function() &#123;</span><br><span class="line">    import(&apos;./handle&apos;).then(fn =&gt; fn.default());</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>import()</code> 语法，需要 <code>@babel/plugin-syntax-dynamic-import</code> 的插件支持，但是因为当前 <code>@babel/preset-env</code> 预设中已经包含了 <code>@babel/plugin-syntax-dynamic-import</code>，因此我们不需要再单独安装和配置。</p>
<p>直接 <code>npm run build</code> 进行构建，构建结果如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef6dc0875?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="WechatIMG1121.jpeg"></p>
<p><code>webpack</code> 遇到 <code>import(****)</code> 这样的语法的时候，会这样处理：</p>
<ul>
<li>以**** 为入口新生成一个 <code>Chunk</code></li>
<li>当代码执行到 <code>import</code> 所在的语句时，才会加载该 <code>Chunk</code> 所对应的文件（如这里的1.bundle.8bf4dc.js）</li>
</ul>
<p>大家可以在浏览器中的控制台中，在 <code>Network</code> 的 <code>Tab页</code> 查看文件加载的情况，只有点击之后，才会加载对应的 <code>JS</code> 。</p>
<h3 id="5-热更新"><a href="#5-热更新" class="headerlink" title="5.热更新"></a>5.热更新</h3><ol>
<li>首先配置 <code>devServer</code> 的 <code>hot</code> 为 <code>true</code></li>
<li>并且在 <code>plugins</code> 中增加 <code>new webpack.HotModuleReplacementPlugin()</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //....</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        hot: true</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.HotModuleReplacementPlugin() //热更新插件</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们配置了 <code>HotModuleReplacementPlugin</code> 之后，会发现，此时我们修改代码，仍然是整个页面都会刷新。不希望整个页面都刷新，还需要修改入口文件：</p>
<ol>
<li>在入口文件中新增:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(module &amp;&amp; module.hot) &#123;</span><br><span class="line">    module.hot.accept()</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时，再修改代码，不会造成整个页面的刷新。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef7c6718b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="6-多页应用打包"><a href="#6-多页应用打包" class="headerlink" title="6.多页应用打包"></a>6.多页应用打包</h3><p>有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 <code>webpack</code> 进行打包呢。为了生成目录看起来清晰，不生成单独的 <code>map</code> 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &apos;./src/index.js&apos;,</span><br><span class="line">        login: &apos;./src/login.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;[name].[hash:6].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/index.html&apos;,</span><br><span class="line">            filename: &apos;index.html&apos; //打包后的文件名</span><br><span class="line">        &#125;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/login.html&apos;,</span><br><span class="line">            filename: &apos;login.html&apos; //打包后的文件名</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果需要配置多个 <code>HtmlWebpackPlugin</code>，那么 <code>filename</code> 字段不可缺省，否则默认生成的都是 <code>index.html</code>，如果你希望 <code>html</code> 的文件名中也带有 <code>hash</code>，那么直接修改 <code>fliename</code> 字段即可，例如: <code>filename: &#39;login.[hash:6].html&#39;</code>。</p>
<p>生成目录如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">│   ├── 2.463ccf.js</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   └── thor_e09b5c.jpeg</span><br><span class="line">│   ├── css</span><br><span class="line">│   │   ├── index.css</span><br><span class="line">│   │   └── login.css</span><br><span class="line">│   ├── index.463ccf.js</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   │   └── base.js</span><br><span class="line">│   ├── login.463ccf.js</span><br><span class="line">│   └── login.html</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看起来，似乎是OK了，不过呢，查看 <code>index.html</code> 和 <code>login.html</code> 会发现，都同时引入了 <code>index.f7d21a.js</code> 和 <code>login.f7d21a.js</code>，通常这不是我们想要的，我们希望，<code>index.html</code> 中只引入 <code>index.f7d21a.js</code>，<code>login.html</code> 只引入 <code>login.f7d21a.js</code>。</p>
<p><code>HtmlWebpackPlugin</code> 提供了一个 <code>chunks</code> 的参数，可以接受一个数组，配置此参数仅会将数组中指定的js引入到html文件中，此外，如果你需要引入多个JS文件，仅有少数不想引入，还可以指定 <code>excludeChunks</code> 参数，它接受一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/index.html&apos;,</span><br><span class="line">            filename: &apos;index.html&apos;, //打包后的文件名</span><br><span class="line">            chunks: [&apos;index&apos;]</span><br><span class="line">        &#125;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/login.html&apos;,</span><br><span class="line">            filename: &apos;login.html&apos;, //打包后的文件名</span><br><span class="line">            chunks: [&apos;login&apos;]</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行 <code>npm run build</code>，可以看到 <code>index.html</code> 中仅引入了 <code>index</code> 的 <code>JS</code> 文件，而 <code>login.html</code> 中也仅引入了 <code>login</code> 的 <code>JS</code> 文件，符合我们的预期。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7f6f69cfb5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="7-resolve-配置"><a href="#7-resolve-配置" class="headerlink" title="7.resolve 配置"></a>7.resolve 配置</h3><p><code>resolve</code> 配置 <code>webpack</code> 如何寻找模块所对应的文件。<code>webpack</code> 内置 <code>JavaScript</code> 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你可以根据自己的需要修改默认的规则。</p>
<ol>
<li>modules</li>
</ol>
<p><code>resolve.modules</code> 配置 <code>webpack</code> 去哪些目录下寻找第三方模块，默认情况下，只会去 <code>node_modules</code> 下寻找，如果你我们项目中某个文件夹下的模块经常被导入，不希望写很长的路径，那么就可以通过配置 <code>resolve.modules</code> 来简化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //....</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        modules: [&apos;./src/components&apos;, &apos;node_modules&apos;] //从左到右依次查找</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样配置之后，我们 <code>import Dialog from &#39;dialog&#39;</code>，会去寻找 <code>./src/components/dialog</code>，不再需要使用相对路径导入。如果在 <code>./src/components</code> 下找不到的话，就会到 <code>node_modules</code> 下寻找。</p>
<ol>
<li>alias</li>
</ol>
<p><code>resolve.alias</code> 配置项通过别名把原导入路径映射成一个新的导入路径，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //....</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &apos;react-native&apos;: &apos;@my/react-native-web&apos; //这个包名是我随便写的哈</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>例如，我们有一个依赖 <code>@my/react-native-web</code> 可以实现 <code>react-native</code> 转 <code>web</code>。我们代码一般下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; View, ListView, StyleSheet, Animated &#125; from &apos;react-native&apos;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>配置了别名之后，在转 web 时，会从 <code>@my/react-native-web</code> 寻找对应的依赖。</p>
<p>当然啦，如果某个依赖的名字太长了，你也可以给它配置一个短一点的别名，这样用起来比较爽，尤其是带有 <code>scope</code> 的包。</p>
<ol>
<li>extensions</li>
</ol>
<p>适配多端的项目中，可能会出现 <code>.web.js</code>, <code>.wx.js</code>，例如在转web的项目中，我们希望首先找 <code>.web.js</code>，如果没有，再找 <code>.js</code>。我们可以这样配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //....</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [&apos;web.js&apos;, &apos;.js&apos;] //当然，你还可以配置 .json, .css</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>首先寻找 <code>../dialog.web.js</code> ，如果不存在的话，再寻找 <code>../dialog.js</code>。这在适配多端的代码中非常有用，否则，你就需要根据不同的平台去引入文件(以牺牲了速度为代价)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import dialog from &apos;../dialog&apos;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然，配置 <code>extensions</code>，我们就可以缺省文件后缀，在导入语句没带文件后缀时，会自动带上<code>extensions</code> 中配置的后缀后，去尝试访问文件是否存在，因此要将高频的后缀放在前面，并且数组不要太长，减少尝试次数。如果没有配置 <code>extensions</code>，默认只会找对对应的js文件。</p>
<ol>
<li>enforceExtension</li>
</ol>
<p>如果配置了 <code>resolve.enforceExtension</code> 为 <code>true</code>，那么导入语句不能缺省文件后缀。</p>
<ol>
<li>mainFields</li>
</ol>
<p>有一些第三方模块会提供多份代码，例如 <code>bootstrap</code>，可以查看 <code>bootstrap</code> 的 <code>package.json</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;style&quot;: &quot;dist/css/bootstrap.css&quot;,</span><br><span class="line">    &quot;sass&quot;: &quot;scss/bootstrap.scss&quot;,</span><br><span class="line">    &quot;main&quot;: &quot;dist/js/bootstrap&quot;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>resolve.mainFields</code> 默认配置是 <code>[&#39;browser&#39;, &#39;main&#39;]</code>，即首先找对应依赖 <code>package.json</code> 中的 <code>brower</code> 字段，如果没有，找 <code>main</code> 字段。</p>
<p>如：<code>import &#39;bootstrap&#39;</code> 默认情况下，找得是对应的依赖的 <code>package.json</code> 的 <code>main</code> 字段指定的文件，即 <code>dist/js/bootstrap</code>。</p>
<p>假设我们希望，<code>import &#39;bootsrap&#39;</code> 默认去找 <code>css</code> 文件的话，可以配置 <code>resolve.mainFields</code> 为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //....</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        mainFields: [&apos;style&apos;, &apos;main&apos;] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="8-区分不同的环境"><a href="#8-区分不同的环境" class="headerlink" title="8.区分不同的环境"></a>8.区分不同的环境</h3><p>目前为止我们 <code>webpack</code> 的配置，都定义在了 <code>webpack.config.js</code> 中，对于需要区分是开发环境还是生产环境的情况，我们根据 <code>process.env.NODE_ENV</code> 去进行了区分配置，但是配置文件中如果有多处需要区分环境的配置，这种显然不是一个好办法。</p>
<p>更好的做法是创建多个配置文件，如: <code>webpack.base.js</code>、<code>webpack.dev.js</code>、<code>webpack.prod.js</code>。</p>
<ul>
<li><code>webpack.base.js</code> 定义公共的配置</li>
<li><code>webpack.dev.js</code>：定义开发环境的配置</li>
<li><code>webpack.prod.js</code>：定义生产环境的配置</li>
</ul>
<p><a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="noopener">webpack-merge</a> 专为 <code>webpack</code> 设计，提供了一个 <code>merge</code> 函数，用于连接数组，合并对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-merge -D</span><br><span class="line">复制代码</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">merge(&#123;</span><br><span class="line">    devtool: &apos;cheap-module-eval-source-map&apos;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;a: 1&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [1,2,3]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    devtool: &apos;none&apos;,</span><br><span class="line">    mode: &quot;production&quot;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;a: 2&#125;,</span><br><span class="line">            &#123;b: 1&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [4,5,6],</span><br><span class="line">&#125;);</span><br><span class="line">//合并后的结果为</span><br><span class="line">&#123;</span><br><span class="line">    devtool: &apos;none&apos;,</span><br><span class="line">    mode: &quot;production&quot;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;a: 1&#125;,</span><br><span class="line">            &#123;a: 2&#125;,</span><br><span class="line">            &#123;b: 1&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [1,2,3,4,5,6]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>webpack.config.base.js</code> 中是通用的 <code>webpack</code> 配置，以 <code>webpack.config.dev.js</code> 为例，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.dev.js</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const baseWebpackConfig = require(&apos;./webpack.config.base&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">    mode: &apos;development&apos;</span><br><span class="line">    //...其它的一些配置</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后修改我们的 <code>package.json</code>，指定对应的 <code>config</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//package.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config=webpack.config.dev.js&quot;,</span><br><span class="line">        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config=webpack.config.prod.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>merge</code> 合并，也可以使用 <code>merge.smart</code> 合并，<code>merge.smart</code> 在合并<code>loader</code>时，会将同一匹配规则的进行合并，<code>webpack-merge</code> 的说明文档中给出了详细的示例。</p>
<h3 id="9-定义环境变量"><a href="#9-定义环境变量" class="headerlink" title="9.定义环境变量"></a>9.定义环境变量</h3><p>很多时候，我们在开发环境中会使用预发环境或者是本地的域名，生产环境中使用线上域名，我们可以在 <code>webpack</code> 定义环境变量，然后在代码中使用。</p>
<p>使用 <code>webpack</code> 内置插件 <code>DefinePlugin</code> 来定义环境变量。</p>
<p><code>DefinePlugin</code> 中的每个键，是一个标识符.</p>
<ul>
<li>如果 <code>value</code> 是一个字符串，会被当做 <code>code</code> 片段</li>
<li>如果 <code>value</code> 不是一个字符串，会被<code>stringify</code></li>
<li>如果 <code>value</code> 是一个对象，正常对象定义即可</li>
<li>如果 <code>key</code> 中有 <code>typeof</code>，它只针对 <code>typeof</code> 调用定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.dev.js</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DefinePlugin(&#123;</span><br><span class="line">            DEV: JSON.stringify(&apos;dev&apos;), //字符串</span><br><span class="line">            FLAG: &apos;true&apos; //FLAG 是个布尔类型</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">//index.js</span><br><span class="line">if(DEV === &apos;dev&apos;) &#123;</span><br><span class="line">    //开发环境</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    //生产环境</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7f724b6757?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="10-利用webpack解决跨域问题"><a href="#10-利用webpack解决跨域问题" class="headerlink" title="10.利用webpack解决跨域问题"></a>10.利用webpack解决跨域问题</h3><p>假设前端在3000端口，服务端在4000端口，我们通过 <code>webpack</code> 配置的方式去实现跨域。</p>
<p>首先，我们在本地创建一个 <code>server.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/api/user&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;name: &apos;刘小夕&apos;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(4000);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>执行代码(<code>run code</code>)，现在我们可以在浏览器中访问到此接口: <code>http://localhost:4000/api/user</code>。</p>
<p>在 <code>index.js</code> 中请求 <code>/api/user</code>，修改 <code>index.js</code> 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//需要将 localhost:3000 转发到 localhost:4000（服务端） 端口</span><br><span class="line">fetch(&quot;/api/user&quot;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then(data =&gt; console.log(data))</span><br><span class="line">    .catch(err =&gt; console.log(err));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们希望通过配置代理的方式，去访问 4000 的接口。</p>
<h4 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h4><p>修改 <code>webpack</code> 配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &quot;/api&quot;: &quot;http://localhost:4000&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>重新执行 <code>npm run dev</code>，可以看到控制台打印出来了 <code>{name: &quot;刘小夕&quot;}</code>，实现了跨域。</p>
<p>大多情况，后端提供的接口并不包含 <code>/api</code>，即：<code>/user</code>，<code>/info</code>、<code>/list</code> 等，配置代理时，我们不可能罗列出每一个api。</p>
<p>修改我们的服务端代码，并重新执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//server.js</span><br><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/user&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;name: &apos;刘小夕&apos;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(4000);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>尽管后端的接口并不包含 <code>/api</code>，我们在请求后端接口时，仍然以 <code>/api</code> 开头，在配置代理时，去掉 <code>/api</code>，修改配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &apos;/api&apos;: &#123;</span><br><span class="line">                target: &apos;http://localhost:4000&apos;,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    &apos;/api&apos;: &apos;&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>重新执行 <code>npm run dev</code>，在浏览器中访问： <code>http://localhost:3000/</code>，控制台中也打印出了<code>{name: &quot;刘小夕&quot;}</code>，跨域成功，</p>
<h3 id="11-前端模拟数据"><a href="#11-前端模拟数据" class="headerlink" title="11.前端模拟数据"></a>11.前端模拟数据</h3><blockquote>
<p>简单数据模拟</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        before(app) &#123;</span><br><span class="line">            app.get(&apos;/user&apos;, (req, res) =&gt; &#123;</span><br><span class="line">                res.json(&#123;name: &apos;刘小夕&apos;&#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在 <code>src/index.js</code> 中直接请求 <code>/user</code> 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(&quot;user&quot;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then(data =&gt; console.log(data))</span><br><span class="line">    .catch(err =&gt; console.log(err));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 mocker-api mock数据接口</p>
</blockquote>
<p>mocker-api 为 REST API 创建模拟 API。在没有实际 REST API 服务器的情况下测试应用程序时，它会很有用。</p>
<ol>
<li>安装 <a href="https://www.npmjs.com/package/mocker-api" target="_blank" rel="noopener">mocker-api</a>:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install mocker-api -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>在项目中新建mock文件夹，新建 mocker.js.文件，文件如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    &apos;GET /user&apos;: &#123;name: &apos;刘小夕&apos;&#125;,</span><br><span class="line">    &apos;POST /login/account&apos;: (req, res) =&gt; &#123;</span><br><span class="line">        const &#123; password, username &#125; = req.body</span><br><span class="line">        if (password === &apos;888888&apos; &amp;&amp; username === &apos;admin&apos;) &#123;</span><br><span class="line">            return res.send(&#123;</span><br><span class="line">                status: &apos;ok&apos;,</span><br><span class="line">                code: 0,</span><br><span class="line">                token: &apos;sdfsdfsdfdsf&apos;,</span><br><span class="line">                data: &#123; id: 1, name: &apos;刘小夕&apos; &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return res.send(&#123; status: &apos;error&apos;, code: 403 &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>修改 <code>webpack.config.base.js</code>:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const apiMocker = require(&apos;mocker-api&apos;);</span><br><span class="line">module.export = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        before(app)&#123;</span><br><span class="line">            apiMocker(app, path.resolve(&apos;./mock/mocker.js&apos;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以直接在代码中像请求后端接口一样对mock数据进行请求。</p>
<ol>
<li>重启 <code>npm run dev</code>，可以看到，控制台成功打印出来 <code>{name: &#39;刘小夕&#39;}</code></li>
<li>我们再修改下 <code>src/index.js</code>，检查下POST接口是否成功</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//src/index.js</span><br><span class="line">fetch(&quot;/login/account&quot;, &#123;</span><br><span class="line">    method: &quot;POST&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    body: JSON.stringify(&#123;</span><br><span class="line">        username: &quot;admin&quot;,</span><br><span class="line">        password: &quot;888888&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then(data =&gt; console.log(data))</span><br><span class="line">    .catch(err =&gt; console.log(err));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以在控制台中看到接口返回的成功的数据。</p>
<p>进阶篇就到这里结束啦，最后一篇是优化篇。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/03/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E5%9F%BA%E7%A1%80%E7%AF%87)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/03/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E5%9F%BA%E7%A1%80%E7%AF%87)/" itemprop="url">深度解锁Webpack系列(基础篇)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-03T14:32:34+08:00">
                2020-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="带你深度解锁Webpack系列-基础篇"><a href="#带你深度解锁Webpack系列-基础篇" class="headerlink" title="带你深度解锁Webpack系列(基础篇)"></a>带你深度解锁Webpack系列(基础篇)</h1><p>三篇长文带你解锁 <code>Webpack</code> ，希望读完这三篇文章，你能够对 <code>webpack</code> 的各项配置有一个更为清晰的认识。</p>
<h3 id="1-webpack-是什么？"><a href="#1-webpack-是什么？" class="headerlink" title="1.webpack 是什么？"></a>1.webpack 是什么？</h3><p><code>webpack</code> 是一个现代 <code>JavaScript</code> 应用程序的静态模块打包器，当 <code>webpack</code> 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 <code>bundle</code>。</p>
<h3 id="2-webpack-的核心概念"><a href="#2-webpack-的核心概念" class="headerlink" title="2.webpack 的核心概念"></a>2.webpack 的核心概念</h3><ul>
<li>entry: 入口</li>
<li>output: 输出</li>
<li>loader: 模块转换器，用于把模块原内容按照需求转换成新内容</li>
<li>插件(plugins): 扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</li>
</ul>
<h3 id="3-初始化项目"><a href="#3-初始化项目" class="headerlink" title="3.初始化项目"></a>3.初始化项目</h3><p>新建一个文件夹，如: <code>webpack-first</code> (当然，你可以使用任意一个你喜欢的项目名)。推荐大家参考本文一步一步进行配置，不要总是在网上找什么最佳配置，你掌握了<code>webpack</code>之后，根据自己的需求配置出来的，就是最佳配置。</p>
<p>本篇文章对应的项目地址(编写本文时使用): <a href="https://github.com/YvetteLau/webpack/tree/master/webpack-first" target="_blank" rel="noopener">github.com/YvetteLau/w…</a></p>
<p>使用 <code>npm init -y</code> 进行初始化(也可以使用 <code>yarn</code>)。</p>
<p>要使用 <code>webpack</code>，那么必然需要安装 <code>webpack</code>、<code>webpack-cli</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>鉴于前端技术变更迅速，祭出本篇文章基于 <code>webpack</code> 的版本号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── webpack@4.41.5 </span><br><span class="line">└── webpack-cli@3.3.10 </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从 <code>wepack V4.0.0</code> 开始， <code>webpack</code> 是开箱即用的，在不引入任何配置文件的情况下就可以使用。</p>
<p>新建 <code>src/index.js</code> 文件，我们在文件中随便写点什么:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Animal(&apos;dog&apos;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用 <code>npx webpack --mode=development</code> 进行构建，默认是 <code>production</code> 模式，我们为了更清楚得查看打包后的代码，使用 <code>development</code> 模式。</p>
<p>可以看到项目下多了个 <code>dist</code> 目录，里面有一个打包出来的文件 <code>main.js</code>。</p>
<p><code>webpack</code> 有默认的配置，如默认的入口文件是 <code>./src</code>，默认打包到<code>dist/main.js</code>。更多的默认配置可以查看: <code>node_modules/webpack/lib/WebpackOptionsDefaulter.js</code>。</p>
<p>查看 <code>dist/main.js</code> 文件，可以看到，<code>src/index.js</code> 并没有被转义为低版本的代码，这显然不是我们想要的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;./src/index.js&quot;:</span><br><span class="line">        (function (module, exports) &#123;</span><br><span class="line"></span><br><span class="line">            eval(&quot;class Animal &#123;\n    constructor(name) &#123;\n        this.name = name;\n    &#125;\n    getName() &#123;\n        return this.name;\n    &#125;\n&#125;\n\nconst dog = new Animal(&apos;dog&apos;);\n\n//# sourceURL=webpack:///./src/index.js?&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="4-将JS转义为低版本"><a href="#4-将JS转义为低版本" class="headerlink" title="4.将JS转义为低版本"></a>4.将JS转义为低版本</h3><p>前面我们说了 <code>webpack</code> 的四个核心概念，其中之一就是 <code>loader</code>，<code>loader</code> 用于对源代码进行转换，这正是我们现在所需要的。</p>
<p>将JS代码向低版本转换，我们需要使用 <code>babel-loader</code>。</p>
<h4 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h4><p>首先安装一下 <code>babel-loader</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此外，我们还需要配置 <code>babel</code>，为此我们安装一下以下依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line"></span><br><span class="line">npm install @babel/runtime @babel/runtime-corejs3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对babel7配置不熟悉的小伙伴，可以阅读一下这篇文章: <a href="https://juejin.im/post/5ddff3abe51d4502d56bd143" target="_blank" rel="noopener">不可错过的 Babel7 知识</a></p>
<p>新建 <code>webpack.config.js</code>，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.jsx?$/,</span><br><span class="line">                use: [&apos;babel-loader&apos;],</span><br><span class="line">                exclude: /node_modules/ //排除 node_modules 目录</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>建议给 <code>loader</code> 指定 <code>include</code> 或是 <code>exclude</code>，指定其中一个即可，因为 <code>node_modules</code> 目录通常不需要我们去编译，排除后，有效提升编译效率。</p>
<p>这里，我们可以在 <code>.babelrc</code> 中编写 <code>babel</code> 的配置，也可以在 <code>webpack.config.js</code> 中进行配置。</p>
<h4 id="创建一个-babelrc"><a href="#创建一个-babelrc" class="headerlink" title="创建一个 .babelrc"></a>创建一个 .babelrc</h4><p>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;@babel/preset-env&quot;],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;corejs&quot;: 3</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在，我们重新执行 <code>npx webpack --mode=development</code>，查看 <code>dist/main.js</code>，会发现已经被编译成了低版本的JS代码。</p>
<h4 id="在webpack中配置-babel"><a href="#在webpack中配置-babel" class="headerlink" title="在webpack中配置 babel"></a>在webpack中配置 babel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // mode: &apos;development&apos;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.jsx?$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &apos;babel-loader&apos;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&quot;@babel/preset-env&quot;],</span><br><span class="line">                        plugins: [</span><br><span class="line">                            [</span><br><span class="line">                                &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;corejs&quot;: 3</span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里有几点需要说明：</p>
<ul>
<li><code>loader</code> 需要配置在 <code>module.rules</code> 中，<code>rules</code> 是一个数组。</li>
<li><code>loader</code> 的格式为:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.jsx?$/,//匹配规则</span><br><span class="line">    use: &apos;babel-loader&apos;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>或者也可以像下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//适用于只有一个 loader 的情况</span><br><span class="line">&#123;</span><br><span class="line">    test: /\.jsx?$/,</span><br><span class="line">    loader: &apos;babel-loader&apos;,</span><br><span class="line">    options: &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>test</code> 字段是匹配规则，针对符合规则的文件进行处理。</p>
<p><code>use</code> 字段有几种写法</p>
<ul>
<li>可以是一个字符串，例如上面的 <code>use: &#39;babel-loader&#39;</code></li>
<li><code>use</code> 字段可以是一个数组，例如处理CSS文件是，<code>use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</code></li>
<li><code>use</code> 数组的每一项既可以是字符串也可以是一个对象，当我们需要在<code>webpack</code> 的配置文件中对 <code>loader</code> 进行配置，就需要将其编写为一个对象，并且在此对象的 <code>options</code> 字段中进行配置，如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: /\.jsx?$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: &apos;babel-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">                presets: [&quot;@babel/preset-env&quot;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面我们说了如何将JS的代码编译成向下兼容的代码，当然你可以还需要一些其它的 <code>babel</code> 的插件和预设，例如 <code>@babel/preset-react</code>，<code>@babel/plugin-proposal-optional-chaining</code> 等，不过，<code>babel</code> 的配置并非本文的重点，我们继续往下。</p>
<p>不要说细心的小伙伴了，即使是粗心的小伙伴肯定也发现了，我们在使用 <code>webpack</code> 进行打包的时候，一直运行的都是 <code>npx webpack --mode=development</code> 是否可以将 <code>mode</code> 配置在 <code>webpack.config.js</code> 中呢？显然是可以的。</p>
<h3 id="5-mode"><a href="#5-mode" class="headerlink" title="5.mode"></a>5.mode</h3><p>将 <code>mode</code> 增加到 <code>webpack.config.js</code> 中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //....</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>mode</code> 配置项，告知 <code>webpack</code> 使用相应模式的内置优化。</p>
<p><code>mode</code> 配置项，支持以下两个配置:</p>
<ul>
<li><code>development</code>：将 <code>process.env.NODE_ENV</code> 的值设置为 <code>development</code>，启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></li>
<li><code>production</code>：将 <code>process.env.NODE_ENV</code> 的值设置为 <code>production</code>，启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code></li>
</ul>
<p>现在，我们直接使用 <code>npx webpack</code> 进行编译即可。</p>
<h3 id="6-在浏览器中查看页面"><a href="#6-在浏览器中查看页面" class="headerlink" title="6.在浏览器中查看页面"></a>6.在浏览器中查看页面</h3><p>搞了这么久，还不能在浏览器中查看页面，这显然不能忍！</p>
<p>查看页面，难免就需要 <code>html</code> 文件，有小伙伴可能知道，有时我们会指定打包文件中带有 <code>hash</code>，那么每次生成的 <code>js</code> 文件名会有所不同，总不能让我们每次都人工去修改 <code>html</code>，这样不是显得我们很蠢嘛~</p>
<p>我们可以使用 <code>html-webpack-plugin</code> 插件来帮助我们完成这些事情。</p>
<p>首先，安装一下插件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>新建 <code>public</code> 目录，并在其中新建一个 <code>index.html</code> 文件( 文件内容使用 <code>html:5</code> 快捷生成即可)</p>
<p>修改 <code>webpack.config.js</code> 文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//首先引入插件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        //数组 放着所有的webpack插件</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/index.html&apos;,</span><br><span class="line">            filename: &apos;index.html&apos;, //打包后的文件名</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: false, //是否删除属性的双引号</span><br><span class="line">                collapseWhitespace: false, //是否折叠空白</span><br><span class="line">            &#125;,</span><br><span class="line">            // hash: true //是否加上hash，默认是 false</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时执行 <code>npx webpack</code>，可以看到 <code>dist</code> 目录下新增了 <code>index.html</code> 文件，并且其中自动插入了 `` 脚本，引入的是我们打包之后的 js 文件。</p>
<p>这里要多说一点点东西，<code>HtmlWebpackPlugin</code> 还为我们提供了一个 <code>config</code> 的配置，这个配置可以说是非常有用了。</p>
<h4 id="html-webpack-plugin-的-config-的妙用"><a href="#html-webpack-plugin-的-config-的妙用" class="headerlink" title="html-webpack-plugin 的 config 的妙用"></a>html-webpack-plugin 的 config 的妙用</h4><p>有时候，我们的脚手架不仅仅给自己使用，也许还提供给其它业务使用，<code>html</code> 文件的可配置性可能很重要，比如：你公司有专门的部门提供M页的公共头部/公共尾部，埋点jssdk以及分享的jssdk等等，但是不是每个业务都需要这些内容。</p>
<p>一个功能可能对应多个 <code>js</code> 或者是 <code>css</code> 文件，如果每次都是业务自行修改 <code>public/index.html</code> 文件，也挺麻烦的。首先他们得搞清楚每个功能需要引入的文件，然后才能对 <code>index.html</code> 进行修改。</p>
<p>此时我们可以增加一个配置文件，业务通过设置 <code>true</code> 或 <code>false</code> 来选出自己需要的功能，我们再根据配置文件的内容，为每个业务生成相应的 <code>html</code> 文件，岂不是美美的。</p>
<p>Let’s Go!</p>
<p>首先，我们在 <code>public</code> 目录下新增一个 <code>config.js</code> ( 文件名你喜欢叫什么就叫什么 )，将其内容设置为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//public/config.js 除了以下的配置之外，这里面还可以有许多其他配置，例如,pulicPath 的路径等等</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    dev: &#123;</span><br><span class="line">        template: &#123;</span><br><span class="line">            title: &apos;你好&apos;,</span><br><span class="line">            header: false,</span><br><span class="line">            footer: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    build: &#123;</span><br><span class="line">        template: &#123;</span><br><span class="line">            title: &apos;你好才怪&apos;,</span><br><span class="line">            header: true,</span><br><span class="line">            footer: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在，我们修改下我们的 <code>webpack.config.js</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const isDev = process.env.NODE_ENV === &apos;development&apos;;</span><br><span class="line">const config = require(&apos;./public/config&apos;)[isDev ? &apos;dev&apos; : &apos;build&apos;];</span><br><span class="line"></span><br><span class="line">modue.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    mode: isDev ? &apos;development&apos; : &apos;production&apos;</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/index.html&apos;,</span><br><span class="line">            filename: &apos;index.html&apos;, //打包后的文件名</span><br><span class="line">            config: config.template</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>相应的，我们需要修改下我们的 <code>public/index.html</code> 文件(嵌入的js和css并不存在，仅作为示意)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;% if(htmlWebpackPlugin.options.config.header) &#123; %&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//common/css/header.css&quot;&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">    &lt;title&gt;&lt;%= (htmlWebpackPlugin.options.config.title) %&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;% if(htmlWebpackPlugin.options.config.header) &#123; %&gt;</span><br><span class="line">&lt;script src=&quot;//common/header.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>process.env</code> 中默认并没有 <code>NODE_ENV</code>，这里配置下我们的 <code>package.json</code> 的 <code>scripts</code>.</p>
<p>为了兼容Windows和Mac，我们先安装一下 <code>cross-env</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install cross-env -D</span><br><span class="line">复制代码</span><br><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack&quot;,</span><br><span class="line">        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后我们运行 <code>npm run dev</code> 和 运行 <code>npm run build</code> ，对比下 <code>dist/index.html</code> ，可以看到 <code>npm run build</code>，生成的 <code>index.html</code> 文件中引入了对应的 <code>css</code> 和 <code>js</code>。并且对应的 <code>title</code> 内容也不一样。</p>
<p>你说这里是不是非得是用 <code>NODE_ENV</code> 去判断？当然不是咯，你写 <code>aaa=1</code> ，<code>aaa=2</code> 都行（当然啦，<code>webpack.config.js</code> 和 <code>scripts</code> 都需要进行相应修改），但是可能会被后面接手的人打死。</p>
<p>更多<a href="https://github.com/jantimon/html-webpack-plugin#configuration" target="_blank" rel="noopener">html-webpack-plugin配置项</a></p>
<h4 id="如何在浏览器中实时展示效果"><a href="#如何在浏览器中实时展示效果" class="headerlink" title="如何在浏览器中实时展示效果"></a>如何在浏览器中实时展示效果</h4><p>说了这么多，到现在还没能在浏览器中实时查看效果，是不是已经有点捉急了，先看一下如何实时查看效果吧，不然都不知道自己配得对不对。</p>
<p>话不多说，先装依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改下咱们的 <code>package.json</code> 文件的 <code>scripts</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在控制台执行 <code>npm run dev</code>，启动正常，页面上啥也没有，修改下我们的JS代码，往页面中增加点内容，正常刷新(也就是说不需要进行任何配置就可以使用了)。</p>
<p>Excuse me。怪我平时不认真咯，每次都乖乖的配个 <code>contentBase</code>，原来根本不需要配，带着疑问，我又去搜寻了一番。</p>
<p>原来在配置了 <code>html-webpack-plugin</code> 的情况下， <code>contentBase</code> 不会起任何作用，也就是说我以前都是白配了，这是一个悲伤的故事。</p>
<p>不过呢，我们还是可以在 <code>webpack.config.js</code> 中进行 <code>webpack-dev-server</code> 的其它配置，例如指定端口号，设置浏览器控制台消息，是否压缩等等:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: &apos;3000&apos;, //默认是8080</span><br><span class="line">        quiet: false, //默认不启用</span><br><span class="line">        inline: true, //默认开启 inline 模式，如果设置为false,开启 iframe 模式</span><br><span class="line">        stats: &quot;errors-only&quot;, //终端仅打印 error</span><br><span class="line">        overlay: false, //默认不启用</span><br><span class="line">        clientLogLevel: &quot;silent&quot;, //日志等级</span><br><span class="line">        compress: true //是否启用 gzip 压缩</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>启用 <code>quiet</code> 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 <code>webpack</code> 的错误或警告在控制台不可见 ———— 我是不会开启这个的，看不到错误日志，还搞个锤子</li>
<li><code>stats</code>: “errors-only” ， 终端中仅打印出 <code>error</code>，注意当启用了 <code>quiet</code> 或者是 <code>noInfo</code> 时，此属性不起作用。 ————— 这个属性个人觉得很有用，尤其是我们启用了 <code>eslint</code> 或者使用 <code>TS</code>进行开发的时候，太多的编译信息在终端中，会干扰到我们。</li>
<li>启用 <code>overlay</code> 后，当编译出错时，会在浏览器窗口全屏输出错误，默认是关闭的。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee5021b37bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><code>clientLogLevel</code>: 当使用内联模式时，在浏览器的控制台将显示消息，如：在重新加载之前，在一个错误之前，或者模块热替换启用时。如果你不喜欢看这些信息，可以将其设置为 <code>silent</code> (<code>none</code> 即将被移除)。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee5021f55a7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>本篇文章不是为了细说 <code>webpack-dev-server</code> 的配置，所以这里就不多说了。关于 <code>webpack-dev-server</code> 更多的配置可以<a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">点击查看</a>。</p>
<p>细心的小伙伴可能发现了一个小问题，我们在<code>src/index.js</code>中增加一句 <code>console.log(&#39;aaa&#39;)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Animal(&apos;dog&apos;);</span><br><span class="line">console.log(&apos;aaa&apos;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后通过 <code>npm run dev</code> 查看效果，会发现：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee5022db15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>这显然不是我们源码中对应的行号，点进去的话，会发现代码是被编译后的，我当前的代码非常简单，还能看出来，项目代码复杂后，“亲妈”看编译后都费劲，这不利于我们开发调试，不是我们想要的，我们肯定还是希望能够直接对应到源码的。</p>
<h3 id="7-devtool"><a href="#7-devtool" class="headerlink" title="7.devtool"></a>7.devtool</h3><p><code>devtool</code> 中的一些设置，可以帮助我们将编译后的代码映射回原始源代码。不同的值会明显影响到构建和重新构建的速度。</p>
<p>对我而言，能够定位到源码的行即可，因此，综合构建速度，在开发模式下，我设置的 <code>devtool</code> 的值是 <code>cheap-module-eval-source-map</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devtool: &apos;cheap-module-eval-source-map&apos; //开发环境下使用</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>生产环境可以使用 <code>none</code> 或者是 <code>source-map</code>，使用 <code>source-map</code> 最终会单独打包出一个 <code>.map</code> 文件，我们可以根据报错信息和此 <code>map</code> 文件，进行错误解析，定位到源代码。</p>
<p><code>source-map</code> 和 <code>hidden-source-map</code> 都会打包生成单独的 <code>.map</code> 文件，区别在于，<code>source-map</code> 会在打包出的js文件中增加一个引用注释，以便开发工具知道在哪里可以找到它。<code>hidden-source-map</code> 则不会在打包的js中增加引用注释。</p>
<p>但是我们一般不会直接将 <code>.map</code> 文件部署到CDN，因为会直接映射到源码，更希望将<code>.map</code> 文件传到错误解析系统，然后根据上报的错误信息，直接解析到出错的源码位置。</p>
<p>还可以设置其他的<a href="http://webpack.html.cn/configuration/devtool.html" target="_blank" rel="noopener">devtool值</a>，你可以使用不同的值，构建对比差异。</p>
<p>现在我们已经说了 <code>html</code>、<code>js</code> 了，并且也可以在浏览器中实时看到效果了，现在就不得不说页面开发三巨头之一的 <code>css</code> 。</p>
<h3 id="8-如何处理样式文件呢"><a href="#8-如何处理样式文件呢" class="headerlink" title="8.如何处理样式文件呢"></a>8.如何处理样式文件呢</h3><p><code>webpack</code> 不能直接处理 <code>css</code>，需要借助 <code>loader</code>。如果是 <code>.css</code>，我们需要的 <code>loader</code> 通常有： <code>style-loader</code>、<code>css-loader</code>，考虑到兼容性问题，还需要 <code>postcss-loader</code>，而如果是 <code>less</code> 或者是 <code>sass</code> 的话，还需要 <code>less-loader</code> 和 <code>sass-loader</code>，这里配置一下 <code>less</code> 和 <code>css</code> 文件(<code>sass</code> 的话，使用 <code>sass-loader</code>即可):</p>
<p>先安装一下需要使用的依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader less-loader css-loader postcss-loader autoprefixer less -D</span><br><span class="line">复制代码</span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(le|c)ss$/,</span><br><span class="line">                use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &#123;</span><br><span class="line">                    loader: &apos;postcss-loader&apos;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        plugins: function () &#123;</span><br><span class="line">                            return [</span><br><span class="line">                                require(&apos;autoprefixer&apos;)(&#123;</span><br><span class="line">                                    &quot;overrideBrowserslist&quot;: [</span><br><span class="line">                                        &quot;&gt;0.25%&quot;,</span><br><span class="line">                                        &quot;not dead&quot;</span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;)</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, &apos;less-loader&apos;],</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>测试一下，新建一个 <code>less</code> 文件，<code>src/index.less</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//src/index.less</span><br><span class="line">@color: red;</span><br><span class="line">body&#123;</span><br><span class="line">    background: @color;</span><br><span class="line">    transition: all 2s;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再在入口文件中引入此 <code>less</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//src/index.js</span><br><span class="line">import &apos;./index.less&apos;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们修改了配置文件，重新启动一下服务: <code>npm run dev</code>。可以看到页面的背景色变成了红色。</p>
<p>OK，我们简单说一下上面的配置：</p>
<ul>
<li><code>style-loader</code> 动态创建 <code>style</code> 标签，将 <code>css</code> 插入到 <code>head</code> 中.</li>
<li><code>css-loader</code> 负责处理 <code>@import</code> 等语句。</li>
<li><code>postcss-loader</code> 和 <code>autoprefixer</code>，自动生成浏览器兼容性前缀 —— 2020了，应该没人去自己徒手去写浏览器前缀了吧</li>
<li><code>less-loader</code> 负责处理编译 <code>.less</code> 文件,将其转为 <code>css</code></li>
</ul>
<p>这里，我们之间在 <code>webpack.config.js</code> 写了 <code>autoprefixer</code> 需要兼容的浏览器，仅是为了方便展示。推荐大家在根目录下创建 <code>.browserslistrc</code>，将对应的规则写在此文件中，除了 <code>autoprefixer</code> 使用外，<code>@babel/preset-env</code>、<code>stylelint</code>、<code>eslint-plugin-conmpat</code> 等都可以共用。</p>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader` 的执行顺序是从右向左执行的，也就是后面的 `loader` 先执行，上面 `loader` 的执行顺序为: `less-loader` ---&gt; `postcss-loader` ---&gt; `css-loader` ---&gt; `style-loader</span><br></pre></td></tr></table></figure>

<p>当然，<code>loader</code> 其实还有一个参数，可以修改优先级，<code>enforce</code> 参数，其值可以为: <code>pre</code>(优先执行) 或 <code>post</code> (滞后执行)。</p>
<p>现在，我们已经可以处理 <code>.less</code> 文件啦，<code>.css</code> 文件只需要修改匹配规则，删除 <code>less-loader</code> 即可。</p>
<p>现在的一切看起来都很完美，但是假设我们的文件中使用了本地的图片，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background: url(&apos;../images/thor.png&apos;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>你就会发现，报错啦啦啦，那么我们要怎么处理图片或是本地的一些其它资源文件呢。不用想，肯定又需要 <code>loader</code> 出马了。</p>
<h3 id="9-图片-字体文件处理"><a href="#9-图片-字体文件处理" class="headerlink" title="9.图片/字体文件处理"></a>9.图片/字体文件处理</h3><p>我们可以使用 <code>url-loader</code> 或者 <code>file-loader</code> 来处理本地的资源文件。<code>url-loader</code> 和 <code>file-loader</code> 的功能类似，但是 <code>url-loader</code> 可以指定在文件大小小于指定的限制时，返回 <code>DataURL</code>，因此，个人会优先选择使用 <code>url-loader</code>。</p>
<p>首先安装依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee506dad2eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>安装 <code>url-loader</code> 的时候，控制台会提示你，还需要安装下 <code>file-loader</code>，听人家的话安装下就行(新版 <code>npm</code> 不会自动安装 <code>peerDependencies</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在 <code>webpack.config.js</code> 中进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    modules: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &apos;url-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: 10240, //10K</span><br><span class="line">                            esModule: false </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此处设置 <code>limit</code> 的值大小为 10240，即资源大小小于 <code>10K</code> 时，将资源转换为 <code>base64</code>，超过 10K，将图片拷贝到 <code>dist</code> 目录。<code>esModule</code> 设置为 <code>false</code>，否则，<code>会出现</code></p>
<p>将资源转换为 <code>base64</code> 可以减少网络请求次数，但是 <code>base64</code> 数据较大，如果太多的资源是 <code>base64</code>，会导致加载变慢，因此设置 <code>limit</code> 值时，需要二者兼顾。</p>
<p>默认情况下，生成的文件的文件名就是文件内容的 <code>MD5</code> 哈希值并会保留所引用资源的原始扩展名，例如我上面的图片(thor.jpeg)对应的文件名如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee50ad69750?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>当然，你也可以通过 <code>options</code> 参数进行修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//....</span><br><span class="line">use: [</span><br><span class="line">    &#123;</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: 10240, //10K</span><br><span class="line">            esModule: false,</span><br><span class="line">            name: &apos;[name]_[hash:6].[ext]&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>重新编译，在浏览器中审查元素，可以看到图片名变成了: <code>thor_a5f7c0.jpeg</code>。</p>
<p>当本地资源较多时，我们有时会希望它们能打包在一个文件夹下，这也很简单，我们只需要在 <code>url-loader</code> 的 <code>options</code> 中指定 <code>outpath</code>，如: <code>outputPath: &#39;assets&#39;</code>，构建出的目录如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee50d59a0cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>更多的 <code>url-loader</code> 配置可以<a href="https://www.webpackjs.com/loaders/url-loader/" target="_blank" rel="noopener">查看</a></p>
<p>到了这里，有点<strong>岁月静好</strong>的感觉了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee545e78629?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>不过还没完，如果你在 <code>public/index.html</code> 文件中，使用本地的图片，例如，我们修改一下 <code>public/index.html</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;./a.jpg&quot; /&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>重启本地服务，虽然，控制台不会报错，但是你会发现，浏览器中根本加载不出这张图片，Why？因为构建之后，通过相对路径压根找不着这张图片呀。</p>
<p>How？怎么解决呢？</p>
<h3 id="10-处理-html-中的本地图片"><a href="#10-处理-html-中的本地图片" class="headerlink" title="10.处理 html 中的本地图片"></a>10.处理 html 中的本地图片</h3><p>安装 <code>html-withimg-loader</code> 来解决咯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>修改 <code>webpack.config.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.html$/,</span><br><span class="line">                use: &apos;html-withimg-loader&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后在我们的 <code>html</code> 中引入一张文件测试一下（图片地址自己写咯，这里只是示意）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;img src=&quot;./thor.jpeg&quot; /&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>重启本地服务，图片并没能加载，审查元素的话，会发现图片的地址显示的是 <code>{&quot;default&quot;:&quot;assets/thor_a5f7c0.jpeg&quot;}</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/2/17098ee552daf18d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>我当前 <code>file-loader</code> 的版本是 5.0.2，5版本之后，需要增加 <code>esModule</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    modules: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &apos;url-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: 10240, //10K</span><br><span class="line">                            esModule: false</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再重启本地服务，就搞定啦。</p>
<p>话说使用 <code>html-withimg-loader</code> 处理图片之后，<code>html</code> 中就不能使用 <code>vm</code>, <code>ejs</code> 的模板了，如果想继续在 <code>html</code> 中使用 <code>&lt;% if(htmlWebpackPlugin.options.config.header) { %&gt;</code> 这样的语法，但是呢，又希望能使用本地图片，可不可以？鱼和熊掌都想要，虽然很多时候，能吃个鱼就不错了，但是这里是可以的哦，像下面这样编写图片的地址，并且删除<code>html-withimg-loader</code>的配置即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;img src=&quot;&lt;%= require(&apos;./thor.jpeg&apos;) %&gt;&quot; /&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>图片加载OK啦，并且 <code>&lt;% %&gt;</code> 语法也可以正常使用，吼吼吼<del>~</del></p>
<p>虽然，<code>webpack</code> 的默认配置很好用，但是有的时候，我们会有一些其它需要啦，例如，我们不止一个入口文件，这时候，该怎么办呢？</p>
<h3 id="11-入口配置"><a href="#11-入口配置" class="headerlink" title="11.入口配置"></a>11.入口配置</h3><p>入口的字段为: <code>entry</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos; //webpack的默认配置</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>entry</code> 的值可以是一个字符串，一个数组或是一个对象。</p>
<p>字符串的情况无需多说，就是以对应的文件为入口。</p>
<p>为数组时，表示有“多个主入口”，想要多个依赖文件一起注入时，会这样配置。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">    &apos;./src/polyfills.js&apos;,</span><br><span class="line">    &apos;./src/index.js&apos;</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>polyfills.js</code> 文件中可能只是简单的引入了一些 <code>polyfill</code>，例如 <code>babel-polyfill</code>，<code>whatwg-fetch</code> 等，需要在最前面被引入（我在 webpack2 时这样配置过）。</p>
<p>那什么时候是对象呢？不要捉急，后面将多页配置的时候，会说到。</p>
<h3 id="12-出口配置"><a href="#12-出口配置" class="headerlink" title="12.出口配置"></a>12.出口配置</h3><p>配置 <code>output</code> 选项可以控制 <code>webpack</code> 如何输出编译文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;), //必须是绝对路径</span><br><span class="line">        filename: &apos;bundle.js&apos;,</span><br><span class="line">        publicPath: &apos;/&apos; //通常是CDN地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>例如，你最终编译出来的代码部署在 CDN 上，资源的地址为: ‘<a href="https://aaa/BBB/YourProject/XXX" target="_blank" rel="noopener">https://AAA/BBB/YourProject/XXX</a>‘，那么可以将生产的 <code>publicPath</code> 配置为: <code>//AAA/BBB/</code>。</p>
<p>编译时，可以不配置，或者配置为 <code>/</code>。可以在我们之前提及的 <code>config.js</code> 中指定 <code>publicPath</code>（<code>config.js</code> 中区分了 <code>dev</code> 和 <code>public</code>）， 当然还可以区分不同的环境指定配置文件来设置，或者是根据 <code>isDev</code> 字段来设置。</p>
<p>除此之外呢，考虑到CDN缓存的问题，我们一般会给文件名加上 <code>hash</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;), //必须是绝对路径</span><br><span class="line">        filename: &apos;bundle.[hash].js&apos;,</span><br><span class="line">        publicPath: &apos;/&apos; //通常是CDN地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果你觉得 <code>hash</code> 串太长的话，还可以指定长度，例如 <code>bundle.[hash:6].js</code>。使用 <code>npm run build</code> 打包看看吧。</p>
<p>问题出现啦，每次文件修改后，重新打包，导致 <code>dist</code> 目录下的文件越来越多。要是每次打包前，都先清空一下目录就好啦。可不可以做到呢？必须可以！</p>
<h3 id="13-每次打包前清空dist目录"><a href="#13-每次打包前清空dist目录" class="headerlink" title="13.每次打包前清空dist目录"></a>13.每次打包前清空dist目录</h3><p>反正我是懒得手动去清理的，只要你足够懒，你总是会找到好办法的，懒人推动科技进步。这里，我们需要插件: <code>clean-webpack-plugin</code></p>
<p>安装依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin -D</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以前，<code>clean-webpack-plugin</code> 是默认导出的，现在不是，所以引用的时候，需要注意一下。另外，现在构造函数接受的参数是一个对象，可缺省。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        //不需要传参数喔，它可以找到 outputPath</span><br><span class="line">        new CleanWebpackPlugin() </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在你再修改文件，重现构建，生成的hash值和之前dist中的不一样，但是因为每次 <code>clean-webpack-plugin</code> 都会帮我们先清空一波 <code>dist</code> 目录，所以不会出现太多文件，傻傻分不清楚究竟哪个是新生成文件的情况。</p>
<h4 id="希望dist目录下某个文件夹不被清空"><a href="#希望dist目录下某个文件夹不被清空" class="headerlink" title="希望dist目录下某个文件夹不被清空"></a>希望dist目录下某个文件夹不被清空</h4><p>不过呢，有些时候，我们并不希望整个 <code>dist</code> 目录都被清空，比如，我们不希望，每次打包的时候，都删除 <code>dll</code> 目录，以及 <code>dll</code> 目录下的文件或子目录，该怎么办呢？</p>
<p><code>clean-webpack-plugin</code> 为我们提供了参数 <code>cleanOnceBeforeBuildPatterns</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin(&#123;</span><br><span class="line">            cleanOnceBeforeBuildPatterns:[&apos;**/*&apos;, &apos;!dll&apos;, &apos;!dll/**&apos;] //不删除dll目录下的文件</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此外，<code>clean-webpack-plugin</code> 还有一些其它的配置，不过我使用的不多，大家可以查看<a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a></p>
<p>至此，我们算是完成了一个基础配置。但是这不够完美，或者说有些时候，我们还会有一些其它的需求。下一篇关于<code>webpack</code>配置的文章会介绍一些其它的情况。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/" itemprop="url">JavaScript深入之从原型到原型链-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-15T16:47:58+08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<blockquote>
<p>转载自冴羽大大</p>
</blockquote>
</blockquote>
<h1 id="JavaScript深入之从原型到原型链"><a href="#JavaScript深入之从原型到原型链" class="headerlink" title="JavaScript深入之从原型到原型链"></a>JavaScript深入之从原型到原型链</h1><blockquote>
<p>JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。</p>
</blockquote>
<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">'Kevin'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<p>很简单吧，接下来进入正题：</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虽然写在注释里，但是你要注意：</span></span><br><span class="line"><span class="comment">// prototype是函数才会有的属性</span></span><br><span class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p>
<p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p>
<p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png" alt="构造函数和实例原型的关系图"></p>
<p>在这张图中我们用 Object.prototype 表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>
<p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>于是我们更新下关系图：</p>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png" alt="实例与实例原型的关系图"></p>
<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor﻿，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<p>为了验证这一点，我们可以尝试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以再更新下关系图：</p>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png" alt="实例原型与构造函数的关系图"></p>
<p>综上我们已经得出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'Daisy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了  name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'Kevin'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype4.png" alt="原型的原型关系图"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p>
<p>null，我们可以打印：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>然而 null 究竟代表了什么呢？</p>
<p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">《undefined与null的区别》</a> 就是：</p>
<blockquote>
<p>null 表示“没有对象”，即该处不应该有值。</p>
</blockquote>
<p>所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：</p>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png" alt="原型链示意图"></p>
<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p>
<h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<h3 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h3><p>其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
<h2 id="下一篇文章"><a href="#下一篇文章" class="headerlink" title="下一篇文章"></a>下一篇文章</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></p>
<h2 id="深入系列"><a href="#深入系列" class="headerlink" title="深入系列"></a>深入系列</h2><p>JavaScript深入系列目录地址：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog</a>。</p>
<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>
<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/14/DOM/" itemprop="url">DOM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T10:44:14+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-DOM-Document-Object-Model-文档对象模型"><a href="#1-DOM-Document-Object-Model-文档对象模型" class="headerlink" title="1.DOM:Document  Object  Model(文档对象模型)"></a>1.DOM:Document  Object  Model(文档对象模型)</h1><p>DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描<br>绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM 脱胎于<br>Netscape 及微软公司创始的 DHTML（动态 HTML），但现在它已经成为表现和操作页面标记的真正的跨<br>平台、语言中立的方式。</p>
<p><strong><em>IE 中的所有 DOM 对象都是以 COM 对象的形式实现的。这意味着 IE 中的<br>DOM 对象与原生 JavaScript 对象的行为或活动特点并不一致。</em></strong></p>
<h1 id="2-节点层次"><a href="#2-节点层次" class="headerlink" title="2.节点层次"></a>2.节点层次</h1><h2 id="2-1-Node类型"><a href="#2-1-Node类型" class="headerlink" title="2.1 Node类型"></a>2.1 Node类型</h2><h3 id="2-1-1-确定节点类型"><a href="#2-1-1-确定节点类型" class="headerlink" title="2.1.1 确定节点类型"></a>2.1.1 确定节点类型</h3><p>DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。这个 Node 接口<br>JavaScript 中是作为 Node 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。<br>JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。</p>
<p>每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列<br>12 个数值常量来表示，任何节点类型必居其一：</p>
<p> Node.ELEMENT_NODE(1)；<br> Node.ATTRIBUTE_NODE(2)；<br> Node.TEXT_NODE(3)；<br> Node.CDATA_SECTION_NODE(4)；<br> Node.ENTITY_REFERENCE_NODE(5)；<br> Node.ENTITY_NODE(6)；<br> Node.PROCESSING_INSTRUCTION_NODE(7)；<br> Node.COMMENT_NODE(8)；<br> Node.DOCUMENT_NODE(9)；<br> Node.DOCUMENT_TYPE_NODE(10)<br> Node.DOCUMENT_FRAGMENT_NODE(11)<br> Node.NOTATION_NODE(12)。</p>
<p><strong>nodeType确定节点类型</strong><br><code>someNode.nodeType</code> </p>
<p>返回值：节点类型的数字值<br>nodeName 节点名<br>nodeValue 内容，对于元素节点，始终为null  </p>
<h3 id="2-1-2-节点关系"><a href="#2-1-2-节点关系" class="headerlink" title="2.1.2 节点关系"></a>2.1.2 节点关系</h3><ol>
<li><p>父子节点 ：上下两层节点之间的关系。<br>每个节点都有childNodes属性,其中保存着一个 NodeList 对象(类数组)，DOM 结构动态变动会直接反映在NodeList对象中，对应的其中的所有节点都有对应的唯一父节点parentNode。  </p>
<ol>
<li>访问：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var firstChild = someNode.childNodes[0]/firstChild;</span><br><span class="line">var lastChild = someNode.childNodes[someNode.childNodes.length-1]/lastChild;  </span><br><span class="line">var secondChild = someNode.childNodes.item(1); </span><br><span class="line">var count = someNode.childNodes.length;</span><br></pre></td></tr></table></figure></li>
<li>将NodeList转化为数组：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function convertToArray(nodes)&#123; </span><br><span class="line">   var array = null; </span><br><span class="line">   try &#123; </span><br><span class="line">      array = Array.prototype.slice.call(nodes, 0); //针对非 IE 浏览器</span><br><span class="line">    &#125; catch (ex) &#123; </span><br><span class="line">      array = new Array(); </span><br><span class="line">      for (var i=0, len=nodes.length; i &lt; len; i++)&#123; </span><br><span class="line">        array.push(nodes[i]); </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   return array; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><em>由于IE8 及更早版本将 NodeList实现为一个 COM 对象，不能直接截取</em></strong>  </p>
<ol start="3">
<li>判断是否有子节点<br><code>hasChildNodes()</code>在节点包含一或多个子节点的情况下返回 true,比判断length更方便。</li>
</ol>
</li>
</ol>
<ol start="2">
<li>同胞节点 ：包含在childNodes 列表中的每个节点相互之间都是同胞节点。<br>previousSibling和 nextSibling 属性</li>
</ol>
<h3 id="2-1-3-操作节点"><a href="#2-1-3-操作节点" class="headerlink" title="2.1.3 操作节点"></a>2.1.3 操作节点</h3><p>父节点基础上的操作</p>
<ol>
<li><code>parentNode.appendChild( newNode )</code></li>
<li><code>parentNode.insertBefore( newNode,参照节点 )</code></li>
<li><code>parentNode.replaceChild( newNode,要替换的节点 )</code><br><em>以上对节点的操作均为剪切，而非复制</em></li>
<li><code>parentNode.removeChild( 要删除的节点 )</code></li>
</ol>
<p>所有节点公有方法</p>
<ol>
<li><code>cloneNode( true/false )</code><br>创建调用这个方法的节点的一个完全相同的副本,参数为 true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为 false 的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”，除非通过 appendChild()、insertBefore()或 replaceChild()将它添加到文档中。 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt; </span><br><span class="line"> &lt;li&gt;item 1&lt;/li&gt; </span><br><span class="line"> &lt;li&gt;item 2&lt;/li&gt; </span><br><span class="line"> &lt;li&gt;item 3&lt;/li&gt; </span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var deepList = myList.cloneNode(true); </span><br><span class="line">alert(deepList.childNodes.length); //3（IE &lt; 9）或 7（其他浏览器）</span><br><span class="line">var shallowList = myList.cloneNode(false); </span><br><span class="line">alert(shallowList.childNodes.length); //0</span><br></pre></td></tr></table></figure>
<p><strong><em>cloneNode()方法不会复制添加到 DOM 节点中的 JavaScript 属性，例如事件处理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切都不会复制。IE 在此存在一个 bug，即它会复制事件处理程序，所以我们建议在复制之前最好先移除事件处理程序。</em></strong></p>
<ol start="2">
<li><code>normalize()</code></li>
</ol>
<h2 id="2-2-Document类型"><a href="#2-2-Document类型" class="headerlink" title="2.2 Document类型"></a>2.2 Document类型</h2><p>JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。<br>特征：<br> nodeType 的值为 9；<br> nodeName 的值为”#document”；<br> nodeValue 的值为 null；<br> parentNode 的值为 null；<br> ownerDocument 的值为 null；<br> 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或 Comment。</p>
<h3 id="2-2-1-常用子节点"><a href="#2-2-1-常用子节点" class="headerlink" title="2.2.1 常用子节点"></a>2.2.1 常用子节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var html = document.documentElement;</span><br><span class="line">var body = document.body;</span><br><span class="line">//取得文档标题</span><br><span class="line">var originalTitle = document.title;</span><br><span class="line">//取得完整的 URL</span><br><span class="line">var url = document.URL;</span><br><span class="line">//取得域名</span><br><span class="line">var domain = document.domain; </span><br><span class="line">//取得来源页面的 URL</span><br><span class="line">var referrer = document.referrer;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-查找元素"><a href="#2-2-3-查找元素" class="headerlink" title="2.2.3 查找元素"></a>2.2.3 查找元素</h3><ol>
<li>getElementById( ID )<br>ID:要取得的元素的 ID。如果找到相应的元素则<br>返回该元素，如果不存在带有相应 ID 的元素，则返回 null。注意，这里的 ID 必须与页面中元素的 id特性（attribute）严格匹配，包括大小写。<br>如果页面中多个元素的 ID 值相同，getElementById()只返回文档中第一次出现的元素。</li>
<li>getElementsByTagName( 元素标签名 )[]<br>返回一个HTMLCollection对象,动态集合。可以按索引访问，也可以按名称。   可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 item()，而对字符串索引就会调用 namedItem()。<br>最好区分大小写。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var images = document.getElementsByTagName(&quot;img&quot;);</span><br><span class="line">alert(images.length); //输出图像的数量</span><br><span class="line">alert(images[0].src); //输出第一个图像元素的 src 特性</span><br><span class="line">alert(images.item(0).src); //输出第一个图像元素的 src 特性</span><br><span class="line">//HTMLCollection 对象还有一个方法，叫做 namedItem()，使用这个方法可以通过元素的 name特性取得集合中的项。  </span><br><span class="line">&lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt;</span><br><span class="line">var myImage = images.namedItem(&quot;myImage&quot;);</span><br><span class="line">var myImage = images[&quot;myImage&quot;];  </span><br><span class="line">//取得所有元素</span><br><span class="line">var allElements = document.getElementsByTagName(&quot;*&quot;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>getElementsByName()<br>只有 HTMLDocument 类型才有的方法.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;fieldset&gt;     </span><br><span class="line">&lt;legend&gt;Which color do you prefer?&lt;/legend&gt;     </span><br><span class="line">   &lt;ul&gt;         </span><br><span class="line">      &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt; </span><br><span class="line">          &lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt;&lt;/li&gt;         </span><br><span class="line">      &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;green&quot; name=&quot;color&quot; id=&quot;colorGreen&quot;&gt;</span><br><span class="line">         &lt;label for=&quot;colorGreen&quot;&gt;Green&lt;/label&gt;&lt;/li&gt;         </span><br><span class="line">      &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;</span><br><span class="line">         &lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt;&lt;/li&gt;     </span><br><span class="line">   &lt;/ul&gt; </span><br><span class="line">&lt;/fieldset&gt;  </span><br><span class="line"></span><br><span class="line">var radios = document.getElementsByName(&quot;color&quot;);  </span><br><span class="line">//与 getElementsByTagName() 类似， getElementsByName() 方法也会返回一个 HTMLCollectioin 。</span><br><span class="line">//但是，对于这里的单选按钮来说， namedItem() 方法则只会取得第一项（因为每一项的 name 特性都相同）</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>特殊集合<br>document.anchors ，包含文档中所有带 name 特性的 <a> 元素；<br>document.forms ， 包含文档中所有的 <form> 元素；<br>document.images ，包含文档中所有的 <img> 元素；<br>document.links ，包含文档中所有带 href 特性的 <a> 元素。  </p>
<h2 id="2-3-Element-类型"><a href="#2-3-Element-类型" class="headerlink" title="2.3 Element 类型"></a>2.3 Element 类型</h2><p>Element 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。<br>特征：<br>nodeType 的值为 1；<br>nodeName 的值为元素的标签名；<br>nodeValue 的值为 null ；<br>parentNode 可能是 Document 或 Element ；<br>其子节点可能是 Element 、 Text 、 Comment 、 ProcessingInstruction 、 CDATASection 或EntityReference 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1.取元素名，nodeName/tagName</span><br><span class="line"> if (element.tagName.toLowerCase() == &quot;div&quot;)&#123;</span><br><span class="line">     //这样最好（适用于任何文档） </span><br><span class="line"> &#125;  </span><br><span class="line"> //2.操作特性</span><br><span class="line"> getAttribute() 、 setAttribute( 要设置的特性名 ，值 ) 和 removeAttribute() </span><br><span class="line"> //对于style 属性和onclick类似的事件，getAttribute() 返回的是css文本和事件相应代码的字符串，一般不使用 getAttribute() ，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用 getAttribute() 方法。</span><br><span class="line"> // 如果特性不存在， setAttribute()则创建该属性并设置相应的值，通过这个方法设置的特性名会被统一为小写形式。推荐通过属性来设置特性。</span><br><span class="line"> //3.创建元素</span><br><span class="line"> document.createElement(标签名) </span><br><span class="line"> var div = document.createElement(&quot;div&quot;);</span><br><span class="line"> 创建完后要使用appendChild() 、 insertBefore() 或 replaceChild() 方法将元素插入到文档数中，才会在浏览器中显示。</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/BOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/14/BOM/" itemprop="url">BOM(Browser Object Model 浏览器对象模型)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T09:18:06+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模<br>型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任<br>何网页内容无关。多年来，缺少事实上的规范导致 BOM 既有意思又有问题，因为浏览器提供商会按照各<br>自的想法随意去扩展它。于是，浏览器之间共有的对象就成为了事实上的标准。这些对象在浏览器中得以<br>存在，很大程度上是由于它们提供了与浏览器的互操作性。W3C 为了把浏览器中 JavaScript 最基本的部分<br>标准化，已经将 BOM 的主要方面纳入了 HTML5 的规范中。</p>
<h1 id="1-window对象"><a href="#1-window对象" class="headerlink" title="1.window对象"></a>1.window对象</h1><p>&emsp;&emsp;BOM 的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，<br>它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。这意味着<br>在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问<br>parseInt()等方法。</p>
<h2 id="1-1-全局作用域"><a href="#1-1-全局作用域" class="headerlink" title="1.1 全局作用域"></a>1.1 全局作用域</h2><p>有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法。但定义全局变量与在 window 对象上直接定义属性还是有一点差别：</p>
<ol>
<li>全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var age = 29;</span><br><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 false</span><br><span class="line">delete window.age;</span><br><span class="line">//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 true</span><br><span class="line">delete window.color; //returns true</span><br><span class="line">alert(window.age); //29</span><br><span class="line">alert(window.color); //undefined</span><br></pre></td></tr></table></figure></li>
<li>直接访问未定义的变量会抛出错误，但是访问未定义的window属性则不会，会返回undefined。可以知道某个可能未声明的变量是否存在。<h2 id="1-2-导航和打开窗口"><a href="#1-2-导航和打开窗口" class="headerlink" title="1.2 导航和打开窗口"></a>1.2 导航和打开窗口</h2></li>
</ol>
<p><strong>函数</strong>：window.open(URL,窗口目标，特性字符串，是否打开新页面标志)；<br>四个参数中，一般只需要传URL，最后一个参数传_self时新窗口覆盖当前窗口，默认为打开新窗口。<br>特性表：<br><img src="https://i.loli.net/2019/11/19/xvFCBrUjIfqQHDL.png" alt=""><br>表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号<br>表示（注意，整个特性字符串中不允许出现空格），如下面的例子所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.open(&quot;http://www.baidu.com&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong>：新打开窗口的window对象<br><strong>opener属性</strong>：新打开的窗口都有一个opener属性，保存着打开它的原始窗口的window对象。但原始窗口中并没有这样的指针指向弹出窗口。可指定opener为null；<br><strong>opener.close()</strong>：可以关闭本窗口中通过js打开的窗口；<br>不同浏览器使用close()方法的策略不同：</p>
<ol>
<li>ff : 无法关闭</li>
<li>chrome : 直接关闭</li>
<li>ie : 询问用户</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;open&lt;/button&gt;</span><br><span class="line">&lt;button&gt;close&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var oBtn = document.getElementsByTagName(&apos;button&apos;)[0];</span><br><span class="line">  var oBtn1 = document.getElementsByTagName(&apos;button&apos;)[1];</span><br><span class="line">  var wroxWin; </span><br><span class="line">  oBtn.onclick = function()&#123;</span><br><span class="line">    wroxWin = window.open(&quot;http://www.baidu.com/&quot;,&quot;wroxWindow&quot;,</span><br><span class="line">        &quot;height=400,width=400,top=10,left=10,resizable=yes&quot;);</span><br><span class="line">    // wroxWin.opener = null;</span><br><span class="line">    console.log(wroxWin);</span><br><span class="line">  &#125;;</span><br><span class="line">  oBtn1.onclick = function()&#123;</span><br><span class="line">    wroxWin.close();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="1-3-窗口尺寸"><a href="#1-3-窗口尺寸" class="headerlink" title="1.3 窗口尺寸"></a>1.3 窗口尺寸</h1><h2 id="1-3-1可视区尺寸"><a href="#1-3-1可视区尺寸" class="headerlink" title="1.3.1可视区尺寸"></a>1.3.1可视区尺寸</h2><p>document.documentElement.clientWidth<br>document.documentElement.clientHeight<br><img src="https://i.loli.net/2019/11/20/EZJQWcSzdMA4w3R.png" alt=""></p>
<h2 id="1-3-2-滚动条滚动距离"><a href="#1-3-2-滚动条滚动距离" class="headerlink" title="1.3.2 滚动条滚动距离"></a>1.3.2 滚动条滚动距离</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var scrollTop = document.documentElement.scrollTop || document.body.scrollTop(Left)</span><br></pre></td></tr></table></figure>
<h2 id="1-3-3-内容高度（宽度）"><a href="#1-3-3-内容高度（宽度）" class="headerlink" title="1.3.3 内容高度（宽度）"></a>1.3.3 内容高度（宽度）</h2><p>Element.scrollHeight (Width)这个只读属性是一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。<br><img src="https://i.loli.net/2019/11/20/oOgEMeRGT6qQ3Zn.png" alt=""></p>
<h1 id="1-3-4-offsetHeight-Width"><a href="#1-3-4-offsetHeight-Width" class="headerlink" title="1.3.4  offsetHeight /Width"></a>1.3.4  offsetHeight /Width</h1><p>HTMLElement.offsetHeight 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。<br>通常，元素的offsetHeight是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度。<br>对于文档的body对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。<br>这个属性值会被四舍五入为整数值，如果你需要一个浮点数值，请用 element.getBoundingClientRect().<br><img src="https://i.loli.net/2019/11/20/pMmjAqbvItWC9ha.png" alt=""></p>
<h1 id="2-location对象"><a href="#2-location对象" class="headerlink" title="2.location对象"></a>2.location对象</h1><p>最有用的BOM对象之一，既是window的属性，又是document的属性。location存储着当前文档的信息，并且将 URL 解析为独立的片段，可以通过location对象的属性访问，下面是所有的location属性：<br><img src="https://i.loli.net/2019/11/20/TIFaBu38SzwVxWt.png" alt=""></p>
<h2 id="2-1-获取包含查询字符串的对象"><a href="#2-1-获取包含查询字符串的对象" class="headerlink" title="2.1 获取包含查询字符串的对象"></a>2.1 获取包含查询字符串的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getQueryStringArgs()&#123; </span><br><span class="line"> //取得查询字符串并去掉开头的问号</span><br><span class="line">  var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), </span><br><span class="line">  </span><br><span class="line">  //保存数据的对象</span><br><span class="line">  args = &#123;&#125;, </span><br><span class="line">  </span><br><span class="line">  //取得每一项</span><br><span class="line">  items = qs.length ? qs.split(&quot;&amp;&quot;) : [], </span><br><span class="line">  item = null, </span><br><span class="line">  name = null, </span><br><span class="line">  value = null, </span><br><span class="line">  //在 for 循环中使用</span><br><span class="line">  i = 0, </span><br><span class="line">  len = items.length; </span><br><span class="line">  //逐个将每一项添加到 args 对象中</span><br><span class="line">  for (i=0; i &lt; len; i++)&#123; </span><br><span class="line">      item = items[i].split(&quot;=&quot;); </span><br><span class="line">      name = decodeURIComponent(item[0]); </span><br><span class="line">      value = decodeURIComponent(item[1]); </span><br><span class="line">      if (name.length) &#123; </span><br><span class="line">      args[name] = value; </span><br><span class="line">      &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> return args; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-改变浏览器位置"><a href="#2-2-改变浏览器位置" class="headerlink" title="2.2 改变浏览器位置"></a>2.2 改变浏览器位置</h2><ol>
<li><code>location.assign( URL )</code>方法:立即打开新 URL 并在浏览器的历史记录中生成一条记录。修改window.location或者location.href也会调用assign方法，效果相同。修改表中location的属性也可改变浏览器位置。</li>
<li><code>location.replace( URL )</code>,载入新页面且不会生成历史记录，无法回退。</li>
<li><code>location.reload( true(可选) )</code>,重新载入页面，如果调用 reload()<br>时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，需加参数true。位于 reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将 reload()放在代码的最后一行。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/vue%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/10/vue%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url">vue插值表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-10T20:57:43+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。<br>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。<br>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值，即插值表达式。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>1.插值表达式中使用的数据必须先在data中存在，才能实现数据绑定；<br>2.支持js<strong>表达式</strong>,但不支持<del>语句</del>及<del>流控制</del>，可用<strong>三目表达式</strong>；<br>2.要更改的数据必须先存在，视图才会刷新；<br>3.通过索引或者长度的方式改变数组，视图不会刷新，必须使用数组的变异方法，如push、pop、shift、unshift、sort、reverse、splice；<br>4.$set可用来更改对象的值，例：<code>vm.$set(vm.obj, &#39;xxx&#39;, 90);</code>;也可以更改其他元素，大多用来更改对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; &apos;a&apos; &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; 1 &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; true &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; [1, 2, 3] &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; &#123;a: 1, b: 10&#125; &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; 1+1 &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; 1-1 &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; &apos;a&apos; + &apos;b&apos; &#125;&#125;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- &#123;&#123; var a = 10; return a; &#125;&#125; 语句不支持&lt;br/&gt;</span><br><span class="line">    &#123;&#123; if(true) &#123; return &apos;a&apos;&#125; &#125;&#125; 流控制不支持，可用三元表达式&lt;br/&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &#123;&#123; !true ? &apos;a&apos; : &apos;b&apos; &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; name &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; desc &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; arr[0] &#125;&#125;&lt;br/&gt;</span><br><span class="line">    &#123;&#123; obj[&quot;b&quot;] &#125;&#125;&lt;br/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const vm = new Vue(&#123;</span><br><span class="line">      el:&quot;#app&quot;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        name: &apos;ls&apos;,</span><br><span class="line">        desc: &apos;coder&apos;,</span><br><span class="line">        arr: [1, 2, 3],</span><br><span class="line">        obj: &#123;</span><br><span class="line">          a: 1, b: 10</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // vm.$mount(&apos;#app&apos;);另一种挂载方法</span><br><span class="line">    // $el 返回vue作用的DOM元素</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="STAO">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAO_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/10/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8/" itemprop="url">计算属性与侦听器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-10T20:41:07+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CODE/" itemprop="url" rel="index">
                    <span itemprop="name">CODE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-计算属性"><a href="#1-计算属性" class="headerlink" title="1.计算属性"></a>1.计算属性</h1><p>虽然插值表达式中可以插入复杂逻辑，但过于臃肿且难以复用，对于复杂逻辑，应使用计算属性。  </p>
<p><strong>基础例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>计算属性相当于一层缓存，每次都从缓存中取值，只有设计的数据更改后才会重新执行此函数。直接引用，不比写成”reversedMessage()”形式。</p>
<h2 id="1-1-计算属性与方法比较"><a href="#1-1-计算属性与方法比较" class="headerlink" title="1.1 计算属性与方法比较"></a>1.1 计算属性与方法比较</h2><p>上面的例子在插值表达式中调用方法同样可以实现，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者的不同：</p>
<ol>
<li>计算属性是响应式的，只要message的值没有改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，相当于缓存，不必再次执行函数；</li>
<li>相比之下，每次重新渲染调用方法总会重新执行函数，费时费力。但是在不需要缓存的情况下可以使用方法。</li>
</ol>
<h2 id="1-2-计算属性对象形式"><a href="#1-2-计算属性对象形式" class="headerlink" title="1.2 计算属性对象形式"></a>1.2 计算属性对象形式</h2><p>涉及双向绑定时可以用计算属性的对象形式，不常用。<br><strong>例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  </span><br><span class="line">    计算相加: </span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.number=&quot;firstCount&quot; /&gt; +</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.number=&quot;lastCount&quot; /&gt; </span><br><span class="line"></span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      计算结果: &lt;input type=&quot;text&quot; v-model=&quot;sum&quot; /&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstCount: null,</span><br><span class="line">    lastCount: null,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">   sum: &#123;</span><br><span class="line">          get () &#123;</span><br><span class="line">            if(!this.firstCount &amp;&amp; !this.lastCount) &#123;</span><br><span class="line">              return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.firstCount + this.lastCount;</span><br><span class="line">          &#125;,</span><br><span class="line">          set (val) &#123;</span><br><span class="line">            const avg = val / 2;</span><br><span class="line">            this.firstCount = avg;</span><br><span class="line">            this.lastCount = avg;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="2-侦听器watch"><a href="#2-侦听器watch" class="headerlink" title="2.侦听器watch"></a>2.侦听器watch</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; person &#125;&#125;</span><br><span class="line">    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var vm = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: &apos;lushuo&apos;,</span><br><span class="line">      age: 18,</span><br><span class="line">      person:&apos;&apos;</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    // created()&#123;</span><br><span class="line">    //   this.age = 23;</span><br><span class="line">    // &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        // 被观察的属性变化，就会执行相应的函数</span><br><span class="line">        // name改变触发name函数，age改变触发age函数</span><br><span class="line">        // 首次刷新页面时不执行，可以配合methods和生命周期函数来实现</span><br><span class="line">        // name (newVal) &#123;</span><br><span class="line">        //   // newVal 是更改后的值</span><br><span class="line">        //   this.person = `姓名：$&#123;newVal&#125; 年龄：$&#123;this.age&#125;`;</span><br><span class="line">        // &#125;,</span><br><span class="line">        // age (newVal) &#123;</span><br><span class="line">        //   this.person = `姓名：$&#123;this.name&#125; 年龄：$&#123;newVal&#125;`;</span><br><span class="line">        // &#125;</span><br><span class="line">        // watch不仅可以写成函数的形式，还可以写成对象的形式</span><br><span class="line">        // 可以填写其他参数，如immediate：true, 无论有没有数据改变，立即执行</span><br><span class="line">        // 填写immediate后，就不需要配合methods和生命周期函数了</span><br><span class="line">        name: &#123;</span><br><span class="line">          handler (newVal) &#123;</span><br><span class="line">            setTimeout (() =&gt; &#123;</span><br><span class="line">              this.person = `姓名：$&#123;newVal&#125; 年龄：$&#123;this.age&#125;`;</span><br><span class="line">            &#125;, 2000) </span><br><span class="line">          &#125;,</span><br><span class="line">          immediate: true</span><br><span class="line">        &#125;,</span><br><span class="line">        age: &#123;</span><br><span class="line">          handler (newVal) &#123;</span><br><span class="line">            setTimeout (() =&gt; &#123;</span><br><span class="line">              this.person = `姓名：$&#123;this.name&#125; 年龄：$&#123;newVal&#125;`;            </span><br><span class="line">            &#125;, 2000)</span><br><span class="line">          &#125;,</span><br><span class="line">          immediate: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><h2 id="3-1-computed和watch的区别"><a href="#3-1-computed和watch的区别" class="headerlink" title="3.1 computed和watch的区别"></a>3.1 computed和watch的区别</h2><ol>
<li>computed不可执行异步，watch可执行异步；</li>
<li>computed可以观察多个数据，watch只观察一个；</li>
<li>computed可以新生成一个数据，直接在视图中渲染；watch不可，他用的是本身存在的数据，data中存在。</li>
</ol>
<h2 id="3-2-computed和methods的区别"><a href="#3-2-computed和methods的区别" class="headerlink" title="3.2 computed和methods的区别"></a>3.2 computed和methods的区别</h2><p>computed有缓存机制，methods无缓存机制。</p>
<h2 id="3-3-数据查找顺序"><a href="#3-3-数据查找顺序" class="headerlink" title="3.3 数据查找顺序"></a>3.3 数据查找顺序</h2><p><strong>data &gt; methods &gt; computed</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">STAO</p>
              <p class="site-description motion-element" itemprop="description">前端学习</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
		<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1399664349&auto=1&height=66"></iframe>
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">STAO</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
