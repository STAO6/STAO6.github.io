<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.JPG">
  <link rel="icon" type="image/png" href="/img/favicon.JPG">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="前端学习">
  <meta name="author" content="STAO">
  <meta name="keywords" content="">
  <title>深度解锁Webpack系列(进阶篇) - STAO_blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>STAO_blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-02-04 14:32">
      2020年2月4日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="带你深度解锁Webpack系列-进阶篇"><a href="#带你深度解锁Webpack系列-进阶篇" class="headerlink" title="带你深度解锁Webpack系列(进阶篇)"></a>带你深度解锁Webpack系列(进阶篇)</h1><p>三篇长文，带你解锁 <code>Webpack</code> ，希望读完这三篇文章，你能够对 <code>webpack</code> 的各项配置有一个更为清晰的认识。</p>
<p>本文是第二篇，如果你还没有阅读<a href="https://juejin.im/post/5e5c65fc6fb9a07cd00d8838" target="_blank" rel="noopener">《带你深度解锁Webpack系列(基础篇)》</a>，建议阅读之后，再继续阅读本文。</p>
<p>本文会引入更多的 <code>webpack</code> 配置，如果文中有任何错误，欢迎在评论区指正，我会尽快修正。 <code>webpack</code> 优化部分放在了下一篇。</p>
<p>推荐大家参考本文一步一步进行配置，不要总是想着找什么最佳配置，掌握之后，根据自己的需求配置出来的，就是最佳配置。</p>
<p>本文对应的项目地址(编写本文时使用) 供参考：<a href="https://github.com/YvetteLau/webpack/tree/master/webpack-second" target="_blank" rel="noopener">github.com/YvetteLau/w…</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ee866b278?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="img"></p>
<h3 id="1-静态资源拷贝"><a href="#1-静态资源拷贝" class="headerlink" title="1. 静态资源拷贝"></a>1. 静态资源拷贝</h3><p>有些时候，我们需要使用已有的JS文件、CSS文件（本地文件），但是不需要 <code>webpack</code> 编译。例如，我们在 <code>public/index.html</code> 中引入了 <code>public</code> 目录下的 <code>js</code> 或 <code>css</code> 文件。这个时候，如果直接打包，那么在构建出来之后，肯定是找不到对应的 <code>js</code> / <code>css</code> 了。</p>
<blockquote>
<p><code>public</code> 目录结构</p>
</blockquote>
<pre><code class="hljs css">├── <span class="hljs-selector-tag">public</span>
│   ├── <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.js</span>
│   ├── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.html</span>
│   ├── <span class="hljs-selector-tag">js</span>
│   │   ├── <span class="hljs-selector-tag">base</span><span class="hljs-selector-class">.js</span>
│   │   └── <span class="hljs-selector-tag">other</span><span class="hljs-selector-class">.js</span>
│   └── <span class="hljs-selector-tag">login</span><span class="hljs-selector-class">.html</span>
复制代码</code></pre>

<p>现在，我们在 <code>index.html</code> 中引入了 <code>./js/base.js</code>。</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./js/base.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
复制代码</code></pre>

<p>这时候，我们 <code>npm run dev</code>，会发现有找不到该资源文件的报错信息。</p>
<p>对于这个问题，我们可以手动将其拷贝至构建目录，然后在配置 <code>CleanWebpackPlugin</code> 时，注意不要清空对应的文件或文件夹即可，但是如若这个静态文件时不时的还会修改下，那么依赖于手动拷贝，是很容易出问题的。</p>
<p>不要过于相信自己的记性，依赖于手动拷贝的方式，大多数人应该都有过忘记拷贝的经历，你要是说你从来没忘过。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7eedad0932?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="050a81c7-59e4-4596-b08f-62cefce353d0.jpg"></p>
<p>幸运的是，<code>webpack</code> 为我们这些记性不好又爱偷懒的人提供了好用的插件 <a href="https://webpack.js.org/plugins/copy-webpack-plugin/" target="_blank" rel="noopener">CopyWebpackPlugin</a>，它的作用就是将单个文件或整个目录复制到构建目录。</p>
<p>首先安装一下依赖：</p>
<pre><code class="hljs dockerfile">npm install <span class="hljs-keyword">copy</span><span class="bash">-webpack-plugin -D</span>
复制代码</code></pre>

<p>修改配置(当前，需要做的是将 <code>public/js</code> 目录拷贝至 <code>dist/js</code> 目录)：</p>
<pre><code class="hljs typescript"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    <span class="hljs-comment">//...</span>
    plugins: [
        <span class="hljs-keyword">new</span> CopyWebpackPlugin([
            &#123;
                <span class="hljs-keyword">from</span>: <span class="hljs-string">'public/js/*.js'</span>,
                to: path.resolve(__dirname, <span class="hljs-string">'dist'</span>, <span class="hljs-string">'js'</span>),
                flatten: <span class="hljs-literal">true</span>,
            &#125;,
            <span class="hljs-comment">//还可以继续配置其它要拷贝的文件</span>
        ])
    ]
&#125;
复制代码</code></pre>

<p>此时，重新执行 <code>npm run dev</code>，报错信息已经消失。</p>
<p>这里说一下 <code>flatten</code> 这个参数，设置为 <code>true</code>，那么它只会拷贝文件，而不会把文件夹路径都拷贝上，大家可以不设置 <code>flatten</code> 时，看下构建结果。</p>
<p>另外，如果我们要拷贝一个目录下的很多文件，但是想过滤掉某个或某些文件，那么 <code>CopyWebpackPlugin</code> 还为我们提供了 <code>ignore</code> 参数。</p>
<pre><code class="hljs typescript"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    <span class="hljs-comment">//...</span>
    plugins: [
        <span class="hljs-keyword">new</span> CopyWebpackPlugin([
            &#123;
                <span class="hljs-keyword">from</span>: <span class="hljs-string">'public/js/*.js'</span>,
                to: path.resolve(__dirname, <span class="hljs-string">'dist'</span>, <span class="hljs-string">'js'</span>),
                flatten: <span class="hljs-literal">true</span>,
            &#125;
        ], &#123;
            ignore: [<span class="hljs-string">'other.js'</span>]
        &#125;)
    ]
&#125;
复制代码</code></pre>

<p>例如，这里我们忽略掉 <code>js</code> 目录下的 <code>other.js</code> 文件，使用 <code>npm run build</code> 构建，可以看到 <code>dist/js</code> 下不会出现 <code>other.js</code> 文件。 <code>CopyWebpackPlugin</code> 还提供了很多其它的参数，如果当前的配置不能满足你，可以查阅文档进一步修改配置。</p>
<h3 id="2-ProvidePlugin"><a href="#2-ProvidePlugin" class="headerlink" title="2.ProvidePlugin"></a>2.ProvidePlugin</h3><p><code>ProvidePlugin</code> 在我看来，是为懒人准备的，不过也别过度使用，毕竟全局变量不是什么“好东西”。<code>ProvidePlugin</code> 的作用就是不需要 <code>import</code> 或 <code>require</code> 就可以在项目中到处使用。</p>
<p><code>ProvidePlugin</code> 是 <code>webpack</code> 的内置插件，使用方式如下：</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">webpack</span><span class="hljs-selector-class">.ProvidePlugin</span>(&#123;
  <span class="hljs-attribute">identifier1</span>: <span class="hljs-string">'module1'</span>,
  <span class="hljs-attribute">identifier2</span>: [<span class="hljs-string">'module2'</span>, <span class="hljs-string">'property2'</span>]
&#125;);
复制代码</code></pre>

<p>默认寻找路径是当前文件夹 <code>./**</code> 和 <code>node_modules</code>，当然啦，你可以指定全路径。</p>
<p><code>React</code> 大家都知道的，使用的时候，要在每个文件中引入 <code>React</code>，不然立刻抛错给你看。还有就是 <code>jquery</code>, <code>lodash</code> 这样的库，可能在多个文件中使用，但是懒得每次都引入，好嘛，一起来偷个懒，修改下 <code>webpack</code> 的配置:</p>
<pre><code class="hljs java"><span class="hljs-keyword">const</span> webpack = require(<span class="hljs-string">'webpack'</span>);
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">//...</span>
    plugins: [
        <span class="hljs-keyword">new</span> webpack.ProvidePlugin(&#123;
            React: <span class="hljs-string">'react'</span>,
            Component: [<span class="hljs-string">'react'</span>, <span class="hljs-string">'Component'</span>],
            Vue: [<span class="hljs-string">'vue/dist/vue.esm.js'</span>, <span class="hljs-string">'default'</span>],
            $: <span class="hljs-string">'jquery'</span>,
            _map: [<span class="hljs-string">'lodash'</span>, <span class="hljs-string">'map'</span>]
        &#125;)
    ]
&#125;
复制代码</code></pre>

<p>这样配置之后，你就可以在项目中随心所欲的使用 <code>$</code>、<code>_map</code>了，并且写 <code>React</code> 组件时，也不需要 <code>import</code> <code>React</code> 和 <code>Component</code> 了，如果你想的话，你还可以把 <code>React</code> 的 <code>Hooks</code> 都配置在这里。</p>
<p>另外呢，<code>Vue</code> 的配置后面多了一个 <code>default</code>，这是因为 <code>vue.esm.js</code> 中使用的是 <code>export default</code> 导出的，对于这种，必须要指定 <code>default</code>。<code>React</code> 使用的是 <code>module.exports</code> 导出的，因此不要写 <code>default</code>。</p>
<p>另外，就是如果你项目启动了 <code>eslint</code> 的话，记得修改下 <code>eslint</code> 的配置文件，增加以下配置：</p>
<pre><code class="hljs yaml"><span class="hljs-string">&#123;</span>
    <span class="hljs-attr">"globals":</span> <span class="hljs-string">&#123;</span>
        <span class="hljs-attr">"React":</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
        <span class="hljs-attr">"Vue":</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
        <span class="hljs-string">//....</span>
    <span class="hljs-string">&#125;</span>
<span class="hljs-string">&#125;</span>
<span class="hljs-string">复制代码</span></code></pre>

<p>当然啦，偷懒要有个度，你要是配一大堆全局变量，最终可能会给自己带来麻烦，对自己配置的全局变量一定要负责到底。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef26d2ca3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="u=2243033496,1576809017&amp;fm=15&amp;gp=0.jpg"></p>
<h3 id="3-抽离CSS"><a href="#3-抽离CSS" class="headerlink" title="3.抽离CSS"></a>3.抽离CSS</h3><p>CSS打包我们前面已经说过了，不过呢，有些时候，我们可能会有抽离CSS的需求，即将CSS文件单独打包，这可能是因为打包成一个JS文件太大，影响加载速度，也有可能是为了缓存(例如，只有JS部分有改动)，还有可能就是“我高兴”：我想抽离就抽离，谁也管不着。</p>
<p>不管你是因为什么原因要抽离CSS，只要你有需求，我们就可以去实现。</p>
<p>首先，安装 <code>loader</code>:</p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> mini-css-<span class="hljs-keyword">extract</span>-<span class="hljs-keyword">plugin</span> -D
复制代码</code></pre>

<blockquote>
<p><code>mini-css-extract-plugin</code> 和 <code>extract-text-webpack-plugin</code> 相比:</p>
</blockquote>
<ol>
<li>异步加载</li>
<li>不会重复编译(性能更好)</li>
<li>更容易使用</li>
<li>只适用CSS</li>
</ol>
<p>修改我们的配置文件：</p>
<pre><code class="hljs typescript"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    plugins: [
        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;
            filename: <span class="hljs-string">'css/[name].css'</span>
            <span class="hljs-comment">//个人习惯将css文件放在单独目录下</span>
            <span class="hljs-comment">//publicPath:'../'   //如果你的output的publicPath配置的是 './' 这种相对路径，那么如果将css文件放在单独目录下，记得在这里指定一下publicPath </span>
        &#125;)
    ],
    <span class="hljs-keyword">module</span>: &#123;
        rules: [
            &#123;
                test: <span class="hljs-regexp">/\.(le|c)ss$/</span>,
                use: [
                    MiniCssExtractPlugin.loader, <span class="hljs-comment">//替换之前的 style-loader</span>
                    <span class="hljs-string">'css-loader'</span>, &#123;
                        loader: <span class="hljs-string">'postcss-loader'</span>,
                        options: &#123;
                            plugins: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                                <span class="hljs-keyword">return</span> [
                                    <span class="hljs-built_in">require</span>(<span class="hljs-string">'autoprefixer'</span>)(&#123;
                                        <span class="hljs-string">"overrideBrowserslist"</span>: [
                                            <span class="hljs-string">"defaults"</span>
                                        ]
                                    &#125;)
                                ]
                            &#125;
                        &#125;
                    &#125;, <span class="hljs-string">'less-loader'</span>
                ],
                exclude: <span class="hljs-regexp">/node_modules/</span>
            &#125;
        ]
    &#125;
&#125;
复制代码</code></pre>

<p>现在，我们重新编译：<code>npm run build</code>，目录结构如下所示:</p>
<pre><code class="hljs css">.
├── <span class="hljs-selector-tag">dist</span>
│   ├── <span class="hljs-selector-tag">assets</span>
│   │   ├── <span class="hljs-selector-tag">alita_e09b5c</span><span class="hljs-selector-class">.jpg</span>
│   │   └── <span class="hljs-selector-tag">thor_e09b5c</span><span class="hljs-selector-class">.jpeg</span>
│   ├── <span class="hljs-selector-tag">css</span>
│   │   ├── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.css</span>
│   │   └── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.css</span><span class="hljs-selector-class">.map</span>
│   ├── <span class="hljs-selector-tag">bundle</span><span class="hljs-selector-class">.fb6d0c</span><span class="hljs-selector-class">.js</span>
│   ├── <span class="hljs-selector-tag">bundle</span><span class="hljs-selector-class">.fb6d0c</span><span class="hljs-selector-class">.js</span><span class="hljs-selector-class">.map</span>
│   └── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.html</span>
复制代码</code></pre>

<p>前面说了最好新建一个 <code>.browserslistrc</code> 文件，这样可以多个 <code>loader</code> 共享配置，所以，动手在根目录下新建文件 (<code>.browserslistrc</code>)，内容如下（你可以根据自己项目需求，修改为其它的配置）:</p>
<pre><code class="hljs angelscript">last <span class="hljs-number">2</span> version
&gt; <span class="hljs-number">0.25</span>%
<span class="hljs-keyword">not</span> dead
复制代码</code></pre>

<p>修改 <code>webpack.config.js</code>：</p>
<pre><code class="hljs typescript"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    <span class="hljs-comment">//...</span>
    plugins: [
        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;
            filename: <span class="hljs-string">'css/[name].css'</span> 
        &#125;)
    ],
    <span class="hljs-keyword">module</span>: &#123;
        rules: [
            &#123;
                test: <span class="hljs-regexp">/\.(c|le)ss$/</span>,
                use: [
                    MiniCssExtractPlugin.loader,
                    <span class="hljs-string">'css-loader'</span>, &#123;
                        loader: <span class="hljs-string">'postcss-loader'</span>,
                        options: &#123;
                            plugins: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
                                <span class="hljs-keyword">return</span> [
                                    <span class="hljs-built_in">require</span>(<span class="hljs-string">'autoprefixer'</span>)()
                                ]
                            &#125;
                        &#125;
                    &#125;, <span class="hljs-string">'less-loader'</span>
                ],
                exclude: <span class="hljs-regexp">/node_modules/</span>
            &#125;,
        ]
    &#125;
&#125;
复制代码</code></pre>

<p>要测试自己的 <code>.browserlistrc</code> 有没有生效也很简单，直接将文件内容修改为 <code>last 1 Chrome versions</code> ，然后对比修改前后的构建出的结果，就能看出来啦。</p>
<p>可以查看更多[browserslistrc]配置项(<a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">github.com/browserslis…</a>)</p>
<p>更多配置项，可以查看<a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a></p>
<h4 id="将抽离出来的css文件进行压缩"><a href="#将抽离出来的css文件进行压缩" class="headerlink" title="将抽离出来的css文件进行压缩"></a>将抽离出来的css文件进行压缩</h4><p>使用 <code>mini-css-extract-plugin</code>，<code>CSS</code> 文件默认不会被压缩，如果想要压缩，需要配置 <code>optimization</code>，首先安装 <code>optimize-css-assets-webpack-plugin</code>.</p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">optimize</span>-css-assets-webpack-<span class="hljs-keyword">plugin</span> -D
复制代码</code></pre>

<p>修改webpack配置：</p>
<pre><code class="hljs java"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> OptimizeCssPlugin = require(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>);

<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    entry: <span class="hljs-string">'./src/index.js'</span>,
    <span class="hljs-comment">//....</span>
    plugins: [
        <span class="hljs-keyword">new</span> OptimizeCssPlugin()
    ],
&#125;
复制代码</code></pre>

<p>注意，这里将 <code>OptimizeCssPlugin</code> 直接配置在 <code>plugins</code> 里面，那么 <code>js</code> 和 <code>css</code> 都能够正常压缩，如果你将这个配置在 <code>optimization</code>，那么需要再配置一下 <code>js</code> 的压缩(开发环境下不需要去做CSS的压缩，因此后面记得将其放到 <code>webpack.config.prod.js</code> 中哈)。</p>
<p>配置完之后，测试的时候发现，抽离之后，修改 <code>css</code> 文件时，第一次页面会刷新，但是第二次页面不会刷新 —— 好嘛，我平时的业务中用不着抽离 <code>css</code>，这个问题搁置了好多天(准确来说是忘记了)。</p>
<p>3月8号再次修改这篇文章的时候，正好看到了 <code>MiniCssExtractPlugin.loader</code> 对应的 <code>option</code> 设置，我们再次修改下对应的 <code>rule</code>。</p>
<pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span>
    <span class="hljs-attr">rules:</span> <span class="hljs-string">[</span>
        <span class="hljs-string">&#123;</span>
            <span class="hljs-attr">test:</span> <span class="hljs-string">/\.(c|le)ss$/,</span>
            <span class="hljs-attr">use:</span> <span class="hljs-string">[</span>
                <span class="hljs-string">&#123;</span>
                    <span class="hljs-attr">loader:</span> <span class="hljs-string">MiniCssExtractPlugin.loader,</span>
                    <span class="hljs-attr">options:</span> <span class="hljs-string">&#123;</span>
                        <span class="hljs-attr">hmr:</span> <span class="hljs-string">isDev,</span>
                        <span class="hljs-attr">reloadAll:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
                    <span class="hljs-string">&#125;</span>
                <span class="hljs-string">&#125;,</span>
                <span class="hljs-string">//...</span>
            <span class="hljs-string">],</span>
            <span class="hljs-attr">exclude:</span> <span class="hljs-string">/node_modules/</span>
        <span class="hljs-string">&#125;</span>
    <span class="hljs-string">]</span>
<span class="hljs-string">&#125;</span>
<span class="hljs-string">复制代码</span></code></pre>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef4ea39dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="img"></p>
<h3 id="4-按需加载"><a href="#4-按需加载" class="headerlink" title="4.按需加载"></a>4.按需加载</h3><p>很多时候我们不需要一次性加载所有的JS文件，而应该在不同阶段去加载所需要的代码。<code>webpack</code>内置了强大的分割代码的功能可以实现按需加载。</p>
<p>比如，我们在点击了某个按钮之后，才需要使用使用对应的JS文件中的代码，需要使用 <code>import()</code> 语法：</p>
<pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">import</span>(<span class="hljs-string">'./handle'</span>).then(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn.default());
&#125;
复制代码</code></pre>

<p><code>import()</code> 语法，需要 <code>@babel/plugin-syntax-dynamic-import</code> 的插件支持，但是因为当前 <code>@babel/preset-env</code> 预设中已经包含了 <code>@babel/plugin-syntax-dynamic-import</code>，因此我们不需要再单独安装和配置。</p>
<p>直接 <code>npm run build</code> 进行构建，构建结果如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef6dc0875?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="WechatIMG1121.jpeg"></p>
<p><code>webpack</code> 遇到 <code>import(****)</code> 这样的语法的时候，会这样处理：</p>
<ul>
<li>以**** 为入口新生成一个 <code>Chunk</code></li>
<li>当代码执行到 <code>import</code> 所在的语句时，才会加载该 <code>Chunk</code> 所对应的文件（如这里的1.bundle.8bf4dc.js）</li>
</ul>
<p>大家可以在浏览器中的控制台中，在 <code>Network</code> 的 <code>Tab页</code> 查看文件加载的情况，只有点击之后，才会加载对应的 <code>JS</code> 。</p>
<h3 id="5-热更新"><a href="#5-热更新" class="headerlink" title="5.热更新"></a>5.热更新</h3><ol>
<li>首先配置 <code>devServer</code> 的 <code>hot</code> 为 <code>true</code></li>
<li>并且在 <code>plugins</code> 中增加 <code>new webpack.HotModuleReplacementPlugin()</code></li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> webpack = require(<span class="hljs-string">'webpack'</span>);
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">//....</span>
    devServer: &#123;
        hot: <span class="hljs-keyword">true</span>
    &#125;,
    plugins: [
        <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin() <span class="hljs-comment">//热更新插件</span>
    ]
&#125;
复制代码</code></pre>

<p>我们配置了 <code>HotModuleReplacementPlugin</code> 之后，会发现，此时我们修改代码，仍然是整个页面都会刷新。不希望整个页面都刷新，还需要修改入口文件：</p>
<ol>
<li>在入口文件中新增:</li>
</ol>
<pre><code class="hljs crystal"><span class="hljs-keyword">if</span>(<span class="hljs-class"><span class="hljs-keyword">module</span> &amp;&amp; <span class="hljs-title">module</span>.<span class="hljs-title">hot</span>) &#123;</span>
    <span class="hljs-class"><span class="hljs-keyword">module</span>.<span class="hljs-title">hot</span>.<span class="hljs-title">accept</span>()</span>
&#125;
复制代码</code></pre>

<p>此时，再修改代码，不会造成整个页面的刷新。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7ef7c6718b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="img"></p>
<h3 id="6-多页应用打包"><a href="#6-多页应用打包" class="headerlink" title="6.多页应用打包"></a>6.多页应用打包</h3><p>有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 <code>webpack</code> 进行打包呢。为了生成目录看起来清晰，不生成单独的 <code>map</code> 文件。</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    <span class="hljs-attr">entry</span>: &#123;
        <span class="hljs-attr">index</span>: <span class="hljs-string">'./src/index.js'</span>,
        <span class="hljs-attr">login</span>: <span class="hljs-string">'./src/login.js'</span>
    &#125;,
    <span class="hljs-attr">output</span>: &#123;
        <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">'dist'</span>),
        <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[hash:6].js'</span>
    &#125;,
    <span class="hljs-comment">//...</span>
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
            <span class="hljs-attr">template</span>: <span class="hljs-string">'./public/index.html'</span>,
            <span class="hljs-attr">filename</span>: <span class="hljs-string">'index.html'</span> <span class="hljs-comment">//打包后的文件名</span>
        &#125;),
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
            <span class="hljs-attr">template</span>: <span class="hljs-string">'./public/login.html'</span>,
            <span class="hljs-attr">filename</span>: <span class="hljs-string">'login.html'</span> <span class="hljs-comment">//打包后的文件名</span>
        &#125;),
    ]
&#125;
复制代码</code></pre>

<p>如果需要配置多个 <code>HtmlWebpackPlugin</code>，那么 <code>filename</code> 字段不可缺省，否则默认生成的都是 <code>index.html</code>，如果你希望 <code>html</code> 的文件名中也带有 <code>hash</code>，那么直接修改 <code>fliename</code> 字段即可，例如: <code>filename: &#39;login.[hash:6].html&#39;</code>。</p>
<p>生成目录如下:</p>
<pre><code class="hljs css">.
├── <span class="hljs-selector-tag">dist</span>
│   ├── 2<span class="hljs-selector-class">.463ccf</span><span class="hljs-selector-class">.js</span>
│   ├── <span class="hljs-selector-tag">assets</span>
│   │   └── <span class="hljs-selector-tag">thor_e09b5c</span><span class="hljs-selector-class">.jpeg</span>
│   ├── <span class="hljs-selector-tag">css</span>
│   │   ├── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.css</span>
│   │   └── <span class="hljs-selector-tag">login</span><span class="hljs-selector-class">.css</span>
│   ├── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.463ccf</span><span class="hljs-selector-class">.js</span>
│   ├── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.html</span>
│   ├── <span class="hljs-selector-tag">js</span>
│   │   └── <span class="hljs-selector-tag">base</span><span class="hljs-selector-class">.js</span>
│   ├── <span class="hljs-selector-tag">login</span><span class="hljs-selector-class">.463ccf</span><span class="hljs-selector-class">.js</span>
│   └── <span class="hljs-selector-tag">login</span><span class="hljs-selector-class">.html</span>
复制代码</code></pre>

<p>看起来，似乎是OK了，不过呢，查看 <code>index.html</code> 和 <code>login.html</code> 会发现，都同时引入了 <code>index.f7d21a.js</code> 和 <code>login.f7d21a.js</code>，通常这不是我们想要的，我们希望，<code>index.html</code> 中只引入 <code>index.f7d21a.js</code>，<code>login.html</code> 只引入 <code>login.f7d21a.js</code>。</p>
<p><code>HtmlWebpackPlugin</code> 提供了一个 <code>chunks</code> 的参数，可以接受一个数组，配置此参数仅会将数组中指定的js引入到html文件中，此外，如果你需要引入多个JS文件，仅有少数不想引入，还可以指定 <code>excludeChunks</code> 参数，它接受一个数组。</p>
<pre><code class="hljs java"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">//...</span>
    plugins: [
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
            template: <span class="hljs-string">'./public/index.html'</span>,
            filename: <span class="hljs-string">'index.html'</span>, <span class="hljs-comment">//打包后的文件名</span>
            chunks: [<span class="hljs-string">'index'</span>]
        &#125;),
        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
            template: <span class="hljs-string">'./public/login.html'</span>,
            filename: <span class="hljs-string">'login.html'</span>, <span class="hljs-comment">//打包后的文件名</span>
            chunks: [<span class="hljs-string">'login'</span>]
        &#125;),
    ]
&#125;
复制代码</code></pre>

<p>执行 <code>npm run build</code>，可以看到 <code>index.html</code> 中仅引入了 <code>index</code> 的 <code>JS</code> 文件，而 <code>login.html</code> 中也仅引入了 <code>login</code> 的 <code>JS</code> 文件，符合我们的预期。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7f6f69cfb5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="img"></p>
<h3 id="7-resolve-配置"><a href="#7-resolve-配置" class="headerlink" title="7.resolve 配置"></a>7.resolve 配置</h3><p><code>resolve</code> 配置 <code>webpack</code> 如何寻找模块所对应的文件。<code>webpack</code> 内置 <code>JavaScript</code> 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你可以根据自己的需要修改默认的规则。</p>
<ol>
<li>modules</li>
</ol>
<p><code>resolve.modules</code> 配置 <code>webpack</code> 去哪些目录下寻找第三方模块，默认情况下，只会去 <code>node_modules</code> 下寻找，如果你我们项目中某个文件夹下的模块经常被导入，不希望写很长的路径，那么就可以通过配置 <code>resolve.modules</code> 来简化。</p>
<pre><code class="hljs java"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">//....</span>
    resolve: &#123;
        modules: [<span class="hljs-string">'./src/components'</span>, <span class="hljs-string">'node_modules'</span>] <span class="hljs-comment">//从左到右依次查找</span>
    &#125;
&#125;
复制代码</code></pre>

<p>这样配置之后，我们 <code>import Dialog from &#39;dialog&#39;</code>，会去寻找 <code>./src/components/dialog</code>，不再需要使用相对路径导入。如果在 <code>./src/components</code> 下找不到的话，就会到 <code>node_modules</code> 下寻找。</p>
<ol>
<li>alias</li>
</ol>
<p><code>resolve.alias</code> 配置项通过别名把原导入路径映射成一个新的导入路径，例如：</p>
<pre><code class="hljs ceylon"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">module</span>.exports = &#123;
    <span class="hljs-comment">//....</span>
    resolve: &#123;
        <span class="hljs-keyword">alias</span>: &#123;
            <span class="hljs-string">'react-native'</span>: <span class="hljs-string">'@my/react-native-web'</span> <span class="hljs-comment">//这个包名是我随便写的哈</span>
        &#125;
    &#125;
&#125;
复制代码</code></pre>

<p>例如，我们有一个依赖 <code>@my/react-native-web</code> 可以实现 <code>react-native</code> 转 <code>web</code>。我们代码一般下面这样:</p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">View</span>, ListView, StyleSheet, Animated &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
复制代码</code></pre>

<p>配置了别名之后，在转 web 时，会从 <code>@my/react-native-web</code> 寻找对应的依赖。</p>
<p>当然啦，如果某个依赖的名字太长了，你也可以给它配置一个短一点的别名，这样用起来比较爽，尤其是带有 <code>scope</code> 的包。</p>
<ol>
<li>extensions</li>
</ol>
<p>适配多端的项目中，可能会出现 <code>.web.js</code>, <code>.wx.js</code>，例如在转web的项目中，我们希望首先找 <code>.web.js</code>，如果没有，再找 <code>.js</code>。我们可以这样配置:</p>
<pre><code class="hljs java"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">//....</span>
    resolve: &#123;
        extensions: [<span class="hljs-string">'web.js'</span>, <span class="hljs-string">'.js'</span>] <span class="hljs-comment">//当然，你还可以配置 .json, .css</span>
    &#125;
&#125;
复制代码</code></pre>

<p>首先寻找 <code>../dialog.web.js</code> ，如果不存在的话，再寻找 <code>../dialog.js</code>。这在适配多端的代码中非常有用，否则，你就需要根据不同的平台去引入文件(以牺牲了速度为代价)。</p>
<pre><code class="hljs clean"><span class="hljs-keyword">import</span> dialog <span class="hljs-keyword">from</span> <span class="hljs-string">'../dialog'</span>;
复制代码</code></pre>

<p>当然，配置 <code>extensions</code>，我们就可以缺省文件后缀，在导入语句没带文件后缀时，会自动带上<code>extensions</code> 中配置的后缀后，去尝试访问文件是否存在，因此要将高频的后缀放在前面，并且数组不要太长，减少尝试次数。如果没有配置 <code>extensions</code>，默认只会找对对应的js文件。</p>
<ol>
<li>enforceExtension</li>
</ol>
<p>如果配置了 <code>resolve.enforceExtension</code> 为 <code>true</code>，那么导入语句不能缺省文件后缀。</p>
<ol>
<li>mainFields</li>
</ol>
<p>有一些第三方模块会提供多份代码，例如 <code>bootstrap</code>，可以查看 <code>bootstrap</code> 的 <code>package.json</code> 文件：</p>
<pre><code class="hljs 1c">&#123;
    <span class="hljs-string">"style"</span>: <span class="hljs-string">"dist/css/bootstrap.css"</span>,
    <span class="hljs-string">"sass"</span>: <span class="hljs-string">"scss/bootstrap.scss"</span>,
    <span class="hljs-string">"main"</span>: <span class="hljs-string">"dist/js/bootstrap"</span>,
&#125;
复制代码</code></pre>

<p><code>resolve.mainFields</code> 默认配置是 <code>[&#39;browser&#39;, &#39;main&#39;]</code>，即首先找对应依赖 <code>package.json</code> 中的 <code>brower</code> 字段，如果没有，找 <code>main</code> 字段。</p>
<p>如：<code>import &#39;bootstrap&#39;</code> 默认情况下，找得是对应的依赖的 <code>package.json</code> 的 <code>main</code> 字段指定的文件，即 <code>dist/js/bootstrap</code>。</p>
<p>假设我们希望，<code>import &#39;bootsrap&#39;</code> 默认去找 <code>css</code> 文件的话，可以配置 <code>resolve.mainFields</code> 为:</p>
<pre><code class="hljs java"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">//....</span>
    resolve: &#123;
        mainFields: [<span class="hljs-string">'style'</span>, <span class="hljs-string">'main'</span>] 
    &#125;
&#125;
复制代码</code></pre>

<h3 id="8-区分不同的环境"><a href="#8-区分不同的环境" class="headerlink" title="8.区分不同的环境"></a>8.区分不同的环境</h3><p>目前为止我们 <code>webpack</code> 的配置，都定义在了 <code>webpack.config.js</code> 中，对于需要区分是开发环境还是生产环境的情况，我们根据 <code>process.env.NODE_ENV</code> 去进行了区分配置，但是配置文件中如果有多处需要区分环境的配置，这种显然不是一个好办法。</p>
<p>更好的做法是创建多个配置文件，如: <code>webpack.base.js</code>、<code>webpack.dev.js</code>、<code>webpack.prod.js</code>。</p>
<ul>
<li><code>webpack.base.js</code> 定义公共的配置</li>
<li><code>webpack.dev.js</code>：定义开发环境的配置</li>
<li><code>webpack.prod.js</code>：定义生产环境的配置</li>
</ul>
<p><a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="noopener">webpack-merge</a> 专为 <code>webpack</code> 设计，提供了一个 <code>merge</code> 函数，用于连接数组，合并对象。</p>
<pre><code class="hljs angelscript">npm install webpack-merge -D
复制代码
<span class="hljs-keyword">const</span> merge = require(<span class="hljs-string">'webpack-merge'</span>);
merge(&#123;
    devtool: <span class="hljs-string">'cheap-module-eval-source-map'</span>,
    module: &#123;
        rules: [
            &#123;a: <span class="hljs-number">1</span>&#125;
        ]
    &#125;,
    plugins: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
&#125;, &#123;
    devtool: <span class="hljs-string">'none'</span>,
    mode: <span class="hljs-string">"production"</span>,
    module: &#123;
        rules: [
            &#123;a: <span class="hljs-number">2</span>&#125;,
            &#123;b: <span class="hljs-number">1</span>&#125;
        ]
    &#125;,
    plugins: [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],
&#125;);
<span class="hljs-comment">//合并后的结果为</span>
&#123;
    devtool: <span class="hljs-string">'none'</span>,
    mode: <span class="hljs-string">"production"</span>,
    module: &#123;
        rules: [
            &#123;a: <span class="hljs-number">1</span>&#125;,
            &#123;a: <span class="hljs-number">2</span>&#125;,
            &#123;b: <span class="hljs-number">1</span>&#125;
        ]
    &#125;,
    plugins: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
&#125;
复制代码</code></pre>

<p><code>webpack.config.base.js</code> 中是通用的 <code>webpack</code> 配置，以 <code>webpack.config.dev.js</code> 为例，如下：</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//webpack.config.dev.js</span>
<span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>);
<span class="hljs-keyword">const</span> baseWebpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config.base'</span>);

<span class="hljs-built_in">module</span>.exports = merge(baseWebpackConfig, &#123;
    <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>
    <span class="hljs-comment">//...其它的一些配置</span>
&#125;);
复制代码</code></pre>

<p>然后修改我们的 <code>package.json</code>，指定对应的 <code>config</code> 文件：</p>
<pre><code class="hljs 1c"><span class="hljs-comment">//package.json</span>
&#123;
    <span class="hljs-string">"scripts"</span>: &#123;
        <span class="hljs-string">"dev"</span>: <span class="hljs-string">"cross-env NODE_ENV=development webpack-dev-server --config=webpack.config.dev.js"</span>,
        <span class="hljs-string">"build"</span>: <span class="hljs-string">"cross-env NODE_ENV=production webpack --config=webpack.config.prod.js"</span>
    &#125;,
&#125;
复制代码</code></pre>

<p>你可以使用 <code>merge</code> 合并，也可以使用 <code>merge.smart</code> 合并，<code>merge.smart</code> 在合并<code>loader</code>时，会将同一匹配规则的进行合并，<code>webpack-merge</code> 的说明文档中给出了详细的示例。</p>
<h3 id="9-定义环境变量"><a href="#9-定义环境变量" class="headerlink" title="9.定义环境变量"></a>9.定义环境变量</h3><p>很多时候，我们在开发环境中会使用预发环境或者是本地的域名，生产环境中使用线上域名，我们可以在 <code>webpack</code> 定义环境变量，然后在代码中使用。</p>
<p>使用 <code>webpack</code> 内置插件 <code>DefinePlugin</code> 来定义环境变量。</p>
<p><code>DefinePlugin</code> 中的每个键，是一个标识符.</p>
<ul>
<li>如果 <code>value</code> 是一个字符串，会被当做 <code>code</code> 片段</li>
<li>如果 <code>value</code> 不是一个字符串，会被<code>stringify</code></li>
<li>如果 <code>value</code> 是一个对象，正常对象定义即可</li>
<li>如果 <code>key</code> 中有 <code>typeof</code>，它只针对 <code>typeof</code> 调用定义</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-comment">//webpack.config.dev.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;
            <span class="hljs-attr">DEV</span>: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">'dev'</span>), <span class="hljs-comment">//字符串</span>
            <span class="hljs-attr">FLAG</span>: <span class="hljs-string">'true'</span> <span class="hljs-comment">//FLAG 是个布尔类型</span>
        &#125;)
    ]
&#125;
复制代码
<span class="hljs-comment">//index.js</span>
<span class="hljs-keyword">if</span>(DEV === <span class="hljs-string">'dev'</span>) &#123;
    <span class="hljs-comment">//开发环境</span>
&#125;<span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">//生产环境</span>
&#125;
复制代码</code></pre>



<p><img src="https://user-gold-cdn.xitu.io/2020/3/9/170bae7f724b6757?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="img"></p>
<h3 id="10-利用webpack解决跨域问题"><a href="#10-利用webpack解决跨域问题" class="headerlink" title="10.利用webpack解决跨域问题"></a>10.利用webpack解决跨域问题</h3><p>假设前端在3000端口，服务端在4000端口，我们通过 <code>webpack</code> 配置的方式去实现跨域。</p>
<p>首先，我们在本地创建一个 <code>server.js</code>：</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">let</span> app = express();

app.get(<span class="hljs-string">'/api/user'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
    res.json(&#123;name: <span class="hljs-string">'刘小夕'</span>&#125;);
&#125;);

app.listen(<span class="hljs-number">4000</span>);
复制代码</code></pre>

<p>执行代码(<code>run code</code>)，现在我们可以在浏览器中访问到此接口: <code>http://localhost:4000/api/user</code>。</p>
<p>在 <code>index.js</code> 中请求 <code>/api/user</code>，修改 <code>index.js</code> 如下:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//需要将 localhost:3000 转发到 localhost:4000（服务端） 端口</span>
fetch(<span class="hljs-string">"/api/user"</span>)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data))
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));
复制代码</code></pre>

<p>我们希望通过配置代理的方式，去访问 4000 的接口。</p>
<h4 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h4><p>修改 <code>webpack</code> 配置:</p>
<pre><code class="hljs dts"><span class="hljs-comment">//webpack.config.js</span>
module.exports = &#123;
    <span class="hljs-comment">//...</span>
<span class="hljs-symbol">    devServer:</span> &#123;
<span class="hljs-symbol">        proxy:</span> &#123;
            <span class="hljs-string">"/api"</span>: <span class="hljs-string">"http://localhost:4000"</span>
        &#125;
    &#125;
&#125;
复制代码</code></pre>

<p>重新执行 <code>npm run dev</code>，可以看到控制台打印出来了 <code>{name: &quot;刘小夕&quot;}</code>，实现了跨域。</p>
<p>大多情况，后端提供的接口并不包含 <code>/api</code>，即：<code>/user</code>，<code>/info</code>、<code>/list</code> 等，配置代理时，我们不可能罗列出每一个api。</p>
<p>修改我们的服务端代码，并重新执行。</p>
<pre><code class="hljs typescript"><span class="hljs-comment">//server.js</span>
<span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);

<span class="hljs-keyword">let</span> app = express();

app.get(<span class="hljs-string">'/user'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
    res.json(&#123;name: <span class="hljs-string">'刘小夕'</span>&#125;);
&#125;);

app.listen(<span class="hljs-number">4000</span>);
复制代码</code></pre>

<p>尽管后端的接口并不包含 <code>/api</code>，我们在请求后端接口时，仍然以 <code>/api</code> 开头，在配置代理时，去掉 <code>/api</code>，修改配置:</p>
<pre><code class="hljs java"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">//...</span>
    devServer: &#123;
        proxy: &#123;
            <span class="hljs-string">'/api'</span>: &#123;
                target: <span class="hljs-string">'http://localhost:4000'</span>,
                pathRewrite: &#123;
                    <span class="hljs-string">'/api'</span>: <span class="hljs-string">''</span>
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
复制代码</code></pre>

<p>重新执行 <code>npm run dev</code>，在浏览器中访问： <code>http://localhost:3000/</code>，控制台中也打印出了<code>{name: &quot;刘小夕&quot;}</code>，跨域成功，</p>
<h3 id="11-前端模拟数据"><a href="#11-前端模拟数据" class="headerlink" title="11.前端模拟数据"></a>11.前端模拟数据</h3><blockquote>
<p>简单数据模拟</p>
</blockquote>
<pre><code class="hljs coffeescript"><span class="hljs-built_in">module</span>.exports = &#123;
    devServer: &#123;
        before(app) &#123;
            app.get(<span class="hljs-string">'/user'</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;
                res.json(&#123;name: <span class="hljs-string">'刘小夕'</span>&#125;)
            &#125;)
        &#125;
    &#125;
&#125;
复制代码</code></pre>

<p>在 <code>src/index.js</code> 中直接请求 <code>/user</code> 接口。</p>
<pre><code class="hljs javascript">fetch(<span class="hljs-string">"user"</span>)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data))
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));
复制代码</code></pre>

<blockquote>
<p>使用 mocker-api mock数据接口</p>
</blockquote>
<p>mocker-api 为 REST API 创建模拟 API。在没有实际 REST API 服务器的情况下测试应用程序时，它会很有用。</p>
<ol>
<li>安装 <a href="https://www.npmjs.com/package/mocker-api" target="_blank" rel="noopener">mocker-api</a>:</li>
</ol>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> mocker-api -D
复制代码</code></pre>

<ol>
<li>在项目中新建mock文件夹，新建 mocker.js.文件，文件如下:</li>
</ol>
<pre><code class="hljs vim">module.exports = &#123;
    <span class="hljs-string">'GET /user'</span>: &#123;name: <span class="hljs-string">'刘小夕'</span>&#125;,
    <span class="hljs-string">'POST /login/account'</span>: (req, <span class="hljs-keyword">res</span>) =&gt; &#123;
        const &#123; password, username &#125; = req.body
        <span class="hljs-keyword">if</span> (password === <span class="hljs-string">'888888'</span> &amp;&amp; username === <span class="hljs-string">'admin'</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span>.send(&#123;
                statu<span class="hljs-variable">s:</span> <span class="hljs-string">'ok'</span>,
                code: <span class="hljs-number">0</span>,
                token: <span class="hljs-string">'sdfsdfsdfdsf'</span>,
                dat<span class="hljs-variable">a:</span> &#123; id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'刘小夕'</span> &#125;
            &#125;)
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span>.send(&#123; statu<span class="hljs-variable">s:</span> <span class="hljs-string">'error'</span>, code: <span class="hljs-number">403</span> &#125;)
        &#125;
    &#125;
&#125;
复制代码</code></pre>

<ol>
<li>修改 <code>webpack.config.base.js</code>:</li>
</ol>
<pre><code class="hljs reasonml">const apiMocker = require('mocker-api');
<span class="hljs-keyword">module</span>.export = &#123;
    <span class="hljs-comment">//...</span>
    devServer: &#123;
        before(app)&#123;
            api<span class="hljs-constructor">Mocker(<span class="hljs-params">app</span>, <span class="hljs-params">path</span>.<span class="hljs-params">resolve</span>('.<span class="hljs-operator">/</span><span class="hljs-params">mock</span><span class="hljs-operator">/</span><span class="hljs-params">mocker</span>.<span class="hljs-params">js</span>')</span>)
        &#125;
    &#125;
&#125;
复制代码</code></pre>

<p>这样，我们就可以直接在代码中像请求后端接口一样对mock数据进行请求。</p>
<ol>
<li>重启 <code>npm run dev</code>，可以看到，控制台成功打印出来 <code>{name: &#39;刘小夕&#39;}</code></li>
<li>我们再修改下 <code>src/index.js</code>，检查下POST接口是否成功</li>
</ol>
<pre><code class="hljs javascript"><span class="hljs-comment">//src/index.js</span>
fetch(<span class="hljs-string">"/login/account"</span>, &#123;
    <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
    <span class="hljs-attr">headers</span>: &#123;
        <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'application/json'</span>,
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
    &#125;,
    <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(&#123;
        <span class="hljs-attr">username</span>: <span class="hljs-string">"admin"</span>,
        <span class="hljs-attr">password</span>: <span class="hljs-string">"888888"</span>
    &#125;)
&#125;)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data))
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));
复制代码</code></pre>

<p>可以在控制台中看到接口返回的成功的数据。</p>
<p>进阶篇就到这里结束啦，最后一篇是优化篇。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CODE/">CODE</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/webpack/">webpack</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/02/05/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E4%BC%98%E5%8C%96%E7%AF%87)/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深度解锁Webpack系列(优化篇)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/02/03/%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E9%94%81Webpack%E7%B3%BB%E5%88%97(%E5%9F%BA%E7%A1%80%E7%AF%87)/">
                        <span class="hidden-mobile">深度解锁Webpack系列(基础篇)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"name","artist":"artist","url":"http://music.163.com/song/media/outer/url?id=562598065.mp3","cover":"/img/favicon.JPG"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "深度解锁Webpack系列(进阶篇)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
